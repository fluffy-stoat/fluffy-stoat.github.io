{"meta":{},"pages":[{"path":"about/index.html","text":"Hi There我是fluffy-stoat，你可以认为，我的ID之所以这样，是因为我想像白鼬一样，又或是因为我有许多有趣的故事。\n不管怎么说，这就是我——至少是真正的我。\n我是wty，来自SZSHS的一名高一学生、现役OIer，\n说实话，无论是whk还是OI，我的水平都很次，期望各位能以看一个普通人的方式来看待我。\nThoughts了解我的人，知道我自制力不怎么高，知道我总会在意料以外的地方出问题，知道我是个很感性的人\n我思考过不少奇奇怪怪的问题，最后却往往结束以——我依旧什么也不懂、内心更加混乱，还浪费了大把的时间。\n挺无聊的，不是么？\n所以说，我决定听话，广义的听话。\n其实，这样一来，有些事情反倒变得有趣起来了。\n我不是一个有天赋的人，只要你有比我优秀的地方，我乐于接受我的不足，如果你愿意，我也希望能够向你学习。\nEnd好吧好吧~自我介绍就到此为止吧，如果我还有幸能够想起来的话，这篇文章就会一直不定期的更新，感谢朋友们对我的帮助，\n后会有期！\n$Ov-$","title":"About","updated":"2025-09-05T13:37:49.452Z"}],"posts":[{"categories":[],"path":"2025/10/11/test/","tags":[],"text":"This is just a test to see if my latex is crached…\n$1\\le2$","title":"test","updated":"2025-10-11T11:33:38.209Z"},{"categories":[],"path":"2025/09/11/生活杂记/The most important/ToMyDearistFriendAgain/","tags":[],"text":"hmm ~又到了熟悉的环节\n那么~","title":"ToMyDearistFriendAgain","updated":"2025-09-10T16:35:03.207Z"},{"categories":[],"path":"2025/09/05/图论/网络流/","tags":[],"text":"$dinic$前向星建图，便于找反边（编号^$1$），$bfs$给图分层，让他只能流入更低的层，顺便判断出图是否已经阻断无法再流向汇点，$head$每次复制一份，复制出的那一份每次遍历过一条已经被阻塞的边，就直接跟着$next$改到直接指向下一条边，$bfs$时再重新改回初始状态，这是和复杂度的正确性有关的，防止在单点处被卡成$O(E^2)$，$dfs$返回值是这一次又松弛出多少流量。\n123456789101112131415161718192021222324252627282930313233343536ll bfs() &#123; queue&lt;int&gt; q; fp(i, 1, n * 2 * k) dep[i] = inf, nh[i] = head[i]; dep[s] = 0; q.push(s); while (!q.empty()) &#123; ll x = q.front(); q.pop(); for (int i = head[x]; i; i = e[i].next) &#123; if (e[i].w &amp;&amp; dep[e[i].to] == inf) dep[e[i].to] = dep[x] + 1, q.push(e[i].to); &#125; &#125; // cout&lt;&lt;dep[t]&lt;&lt;endl; return dep[t] != inf;&#125;ll dfs(ll x, ll fl) &#123; // cout&lt;&lt;x&lt;&lt;endl; if (x == t) return fl; ll res = 0; for (ll&amp; i = nh[x]; i &amp;&amp; fl; i = e[i].next) &#123; if (dep[e[i].to] == dep[x] + 1) &#123; ll w = dfs(e[i].to, min(fl, e[i].w)); fl -= w; res += w; e[i].w -= w; e[i ^ 1].w += w; &#125; &#125; return res;&#125;//主函数内int main()&#123; while(bfs())ans+=dfs();&#125;\n时间复杂度$O(V^2E)$","title":"网络流","updated":"2025-09-05T13:37:49.446Z"},{"categories":[],"path":"2025/09/05/图论/Kruskal重构树/","tags":[],"text":"Kruskal算法是把边从小到大加入，最终把所有点连成一个联通块。\nKruskal重构树就是同样把边从小到大加入，只不过是重构了一张图，新建了一些节点，这些节点有点权，对应的恰好是原图上的边。\n这样我们就可以利用这新图的一些性质，比较关键的是 原图上的两点在重构树上的LCA的点权就是他们在原图的最小生成树上的简单路径的边权最大值 。\n比较拗口，不过证明还是比较简单的，毕竟越浅的点意味着这个点是越晚加入的，也就意味着它的边权是它所在重构树上子树内点所构成的联通块内最大的。","title":"Kruskal重构树","updated":"2025-09-05T13:37:49.446Z"},{"categories":[],"path":"2025/09/05/杂题选讲/[USACO18DEC] Balance Beam P/","tags":[],"text":"在一个链上，如果每次以等概率向右或向左走，走到$0$或$L$就停，那么在下标为$i$的点走到两边的概率分别为$\\frac{L-i}{L}$和$\\frac{i}{L}$。\n证明：\n设$f_i$为走到$L$的概率，则$$f_0&#x3D;0,f_L&#x3D;1,f_i&#x3D;\\frac{f_{i-1}+f_{i+1}}{2}$$，可以发现这是个等差数列的形式（每个值都是前面和后面的均值，正好把这个数列分成了$L$份$\\frac{1}{L}$）\n那我们知道他从一个点开始肯定不是要让自己啥也得不到，那必然就会在到达他两边的某个点时停下，得分的期望可以用之前我们推出来的式子算，设$i$的两个停止点下标分别为$a,b$，那$i$的期望收获也就是 $$ \\cfrac{v_a(b-i)}{b-a}+\\cfrac{v_b(i-a)}{b-a} $$\n这个东西可以转化为：点$(a,v_a)$到点$(b,v_b)$的直线与直线$x&#x3D;i$的交点的纵坐标，于是我们可以发现这些停止点一定来源于整体的上凸包上，因为不是的话一定有更优的来替代它。\nps:最开始做的时候不会决策，只知道像高斯消元一样列方程，结果列出来个$f_i&#x3D;max(v_i,\\frac{f_{i-1}+f_{i+1}}{2})$就寄了。","title":"USACO18DEC Balance Beam P","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/12/14/表达式树/","tags":[],"text":"","title":"表达式树","updated":"2025-09-05T13:37:49.426Z"},{"categories":[],"path":"2023/12/14/杂题选讲/便捷的缺省源/","tags":[],"text":"123456789101112131415161718192021222324#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define ld long double #define gtc() getchar()#define fp(i,l,r) for(int i=l;i&lt;=r;i++)#define fb(i,l,r) for(int i=l;i&gt;=r;i--)#define pil pair&lt;int,long long&gt;#define pii pair&lt;int,int&gt;template &lt;class T&gt;inline void read(T &amp;s)&#123; T neg=1,ch=gtc();s=0; while(!isdigit(ch))&#123;if(ch==&#x27;-&#x27;)neg=-1;ch=gtc();&#125; while(isdigit(ch))&#123;s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch-&#x27;0&#x27;);ch=gtc();&#125; s=s*neg;&#125;const ll N=100050;ll t,n,m;int main()&#123; /*freopen(,,stdin); freopen(,,stdout);*/ return 0;&#125;","title":"便捷的缺省源","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/12/14/数据结构/单侧递归/","tags":[],"text":"","title":"单侧递归","updated":"2025-09-05T13:37:49.444Z"},{"categories":[],"path":"2023/10/25/图论/连通性专题/","tags":[],"text":"前情提要（说给自己的）：别tm再害怕写这玩意了，又不难，码量小，你自己已经写了多少回了自己没数吗，难调吗？不吧。前情提要（内容的）： dfn 和 low 数组将对Tarjan产生重大影响，所以此处重申这俩的含义—— dfn 是每个点第一次被遍历的顺序， low 是每个点跳一次返祖边能到的最小 dfn\n强连通分量什么是强连通分量就是有向图上，从任意点开始都能重复相互到达若干次的一堆点，就是一个强连通分量。\n怎么求？好办啊tarjan基本是一个套路。\n那么关于强连通分量，你拎出这么一棵树，他上面还有很多杂边，有从一棵子树插到另一棵的横插边有返回自己祖先之一的返祖边有向自己孙子的前向边当然，可能没有树边吗\n上面信息很多、很乱，我们该怎么判断，首先前向边没有用，这显然；其次返祖边有用，至关重要，因为它毫无疑问是造出强连通分量的边，用它可以更新从它到它能达到的那个祖先这一条路上的low；再说说横插边，emm~有用但不是非常有用，它有用是因为它确实可以扩大强连通分量，提前解释一下，有不理解的人可能会感觉程序里横插边更新不了，事实不是这样的，因为既然自己身为那个横插边连向的已遍历部分的low的子树内一点，这个点的子树必定没遍历完，它的强连通分量也就还没结算，那些已遍历过的部分也就没有退栈，因而横插边可以更新到这个点。\n好了，上代码，\n123456789101112131415161718void dfs(ll x) &#123; dfn[x] = low[x] = ++tot; stk[++top] = x; instk[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; if (!dfn[e[i].to]) dfs(e[i].to), low[x] = min(low[x], low[e[i].to]); else if (instk[e[i].to]) low[x] = min(low[x], dfn[e[i].to]); &#125; if (dfn[x] == low[x]) &#123; id++; do &#123; newid[stk[top]] = id; instk[stk[top--]] = 0; &#125; while (instk[x]); &#125;&#125; 边双连通分量","title":"连通性专题","updated":"2025-09-05T13:37:49.446Z"},{"categories":[],"path":"2023/10/25/杂题选讲/模拟退火/","tags":[],"text":"","title":"模拟退火","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/10/25/数据结构/区间数颜色-树上区间并求和/","tags":[],"text":"首先是比较简单的那一个——\n给一个链，上面一堆带颜色点，每次询问区间内不同颜色个数。\n考虑把询问按右端点排序，从左往右扫这个链，每扫到一个颜色就把他到上一次出现此颜色的区间集体加1，用树状数组支持区间加单点查，查一个位置的含义是当左端点在这个位置时区间内不同颜色的个数。\n这个是朴素的。\n接下来上一点难度——\n还是一个链，但是每个点有点权，给一些区间，每次查询一个区间内的区间的并里包含点的权值和。\n这个比较棘手，但还是可以考虑把询问按右端点从小到大排序，从左到右扫那些区间，扫到一个区间，这个区间内的点就挨个给他们到他们上一次出现那一段时间的贡献加上自己的贡献，再集体打上当前的时间标记。\n暴力肯定是不行的，但是可以用线段树辅助操作，考虑到每一次操作最多只会分裂出原来的两个区域，而且吞掉原来的断点以后那些端点就不会存在，他覆盖的区间会变成一个整块，所以在线段树上暴力去找区间覆盖同一个标记的先加，再最后对一个大区间覆盖新标记并减，这样干时间复杂度甚至均摊并不占主要部分，而是线段树加树状数组操作的$O(log^2n)$。\n最后是正题——\n树上区间并求和，当然给出的区间也都是一些两点之间的路径。\n前面链的部分其实已经说完了，树链剖分一下就没了，这回是$O(nlog^3n)$的\n原题在这里\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define ld long double #define gtc() getchar()#define fp(i,l,r) for(int i=l;i&lt;=r;i++)#define fb(i,l,r) for(int i=l;i&gt;=r;i--)#define pil pair&lt;int,long long&gt;#define pii pair&lt;int,int&gt;template &lt;class T&gt;inline void read(T &amp;s)&#123; T neg=1,ch=gtc();s=0; while(!isdigit(ch))&#123;if(ch==&#x27;-&#x27;)neg=-1;ch=gtc();&#125; while(isdigit(ch))&#123;s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch-&#x27;0&#x27;);ch=gtc();&#125; s=s*neg;&#125;const ll N=100050;ll n,m,q,dfn[N],dep[N],sz[N],son[N],a[N],top[N],tot,tag[N*10],t[N],pre[N],ans[N],f[N];vector&lt;int&gt; e[N];pii qr[N];struct fqr&#123; ll l,r,p; bool operator &lt;(const fqr &amp;x)const&#123; return r&lt;x.r; &#125;&#125;qs[N];void dfs(ll x,ll fa)&#123; f[x]=fa; dep[x]=dep[fa]+1; sz[x]=1; for(auto i:e[x])&#123; if(i==fa)continue; dfs(i,x); sz[x]+=sz[i]; if(sz[i]&gt;sz[son[x]])son[x]=i; &#125;&#125;void dfs2(ll x,ll fa,ll tp)&#123; top[x]=tp; dfn[x]=++tot; if(son[x])dfs2(son[x],x,tp); for(auto i:e[x])&#123; if(i==fa||i==son[x])continue; dfs2(i,x,i); &#125;&#125;ll lowbit(ll x)&#123;return x&amp;(-x);&#125;void add(ll x,ll v)&#123; for(int i=x;i&lt;=m;i+=lowbit(i))t[i]+=v;&#125;ll query(ll x)&#123; ll res=0; for(int i=x;i;i-=lowbit(i))res+=t[i]; return res;&#125;void modify(ll x,ll l,ll r,ll tl,ll tr,ll v)&#123; if(l&gt;=tl&amp;&amp;r&lt;=tr)&#123; add(v+1,pre[l-1]-pre[r]); tag[x]=v; return; &#125; ll nxt=x&lt;&lt;1,mid=(l+r)&gt;&gt;1; if(tag[x]!=-1)&#123; tag[nxt]=tag[x]; tag[nxt+1]=tag[x]; tag[x]=-1; &#125; if(tl&lt;=mid)modify(nxt,l,mid,tl,tr,v); if(tr&gt;mid)modify(nxt+1,mid+1,r,tl,tr,v);&#125;void del(ll x,ll l,ll r,ll tl,ll tr)&#123; if(l&gt;=tl&amp;&amp;r&lt;=tr&amp;&amp;tag[x]!=-1)&#123; add(tag[x]+1,pre[r]-pre[l-1]); return ; &#125; ll nxt=x&lt;&lt;1,mid=(l+r)&gt;&gt;1; if(tag[x]!=-1)&#123; tag[nxt]=tag[x]; tag[nxt+1]=tag[x]; tag[x]=-1; &#125; if(tl&lt;=mid)del(nxt,l,mid,tl,tr); if(tr&gt;mid)del(nxt+1,mid+1,r,tl,tr);&#125;void upd(ll x)&#123; ll nx=qr[x].first,ny=qr[x].second; while(top[nx]!=top[ny])&#123; if(dep[top[nx]]&gt;dep[top[ny]])swap(nx,ny); del(1,1,n,dfn[top[ny]],dfn[ny]); modify(1,1,n,dfn[top[ny]],dfn[ny],x); ny=f[top[ny]]; &#125; del(1,1,n,min(dfn[nx],dfn[ny]),max(dfn[nx],dfn[ny])); modify(1,1,n,min(dfn[nx],dfn[ny]),max(dfn[nx],dfn[ny]),x);&#125;int main()&#123; freopen(&quot;star.in&quot;,&quot;r&quot;,stdin); freopen(&quot;star.out&quot;,&quot;w&quot;,stdout); read(n),read(m),read(q); fp(i,1,n)read(a[i]); fp(i,1,n-1)&#123; ll u,v; read(u),read(v); e[u].emplace_back(v); e[v].emplace_back(u); &#125; fp(i,1,m)read(qr[i].first),read(qr[i].second); fp(i,1,q)read(qs[i].l),read(qs[i].r),qs[i].p=i; sort(qs+1,qs+1+q); dfs(1,0); dfs2(1,0,1); fp(i,1,n)pre[dfn[i]]+=a[i]; fp(i,1,n)pre[i]+=pre[i-1]; ll nr=0; fp(i,1,q)&#123; while(nr&lt;qs[i].r)upd(++nr); ans[qs[i].p]=query(qs[i].l); &#125; fp(i,1,q)printf(&quot;%lld\\n&quot;,ans[i]); return 0;&#125;","title":"区间数颜色&树上区间并求和","updated":"2025-09-05T13:37:49.446Z"},{"categories":[],"path":"2023/10/12/DP/同余最短路/","tags":[],"text":"","title":"同余最短路","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/10/12/DP/树上容斥/","tags":[],"text":"这题比较抽象，为了防止造成二次疑惑，请不要自己再去思考，还是老老实实看题解吧。\n题目大意：给一个$n(n\\le5000)$个点的树，根是1，定义好点是一个从他到根的路径上没有点权值比他大的点，一个树的权值是$k(k&lt;998244353)$的$c$次方，即$k^c$，给点赋的权值恰好是$n$的排列，问树的权值的期望乘上$n!$。\n首先这肯定是个树形$dp$，那咋做？\n定义状态$f_{x,i}$为点$x$的子树中最小的为好点的点的相对大小是$i$时，这棵子树的贡献。\n转移是平凡的，先把子树一个一个合并，具体就是根据定义插起来统计，牢记第二个状态的含义是做贡献的最小的是第几小就行，最后再插入这棵子树的树根，如果他做了贡献，那他一定是这棵子树里做贡献的最小的点，如果没有，那他一定小于这棵子树里做贡献的最小的点。\n看起来好像就完事了，但事实上，他会出问题，我们会发现，我们钦定一个点不会做贡献不代表他一定不会做贡献，所以我们实际上会重复统计一个合法状态的所有子集状态。\n形象一点，我们的$dp$数组的下标虽然是做贡献的最小的是第几小，但实际上他还是会存下来一些最小的做贡献的点比下标还小的，只不过这种说法虽然好理解却不如前面那种说法好利用。\n那有妹有办法使他只统计自己的贡献而不多统计子集呢，答案是我不知道，但是我们实际上可以把子集的贡献通过转换变成之前的准确的自己的贡献。\n有这么一个东西：$$k^c&#x3D;\\sum_{i&#x3D;0}^{c}{C_c^i(k-1)^i}$$证明如下：$$k^c&#x3D;((k-1)+1)^c$$由二项式定理：$$((k-1)+1)^c&#x3D;\\sum_{i&#x3D;0}^{c}{C_c^i(k-1)^{c-i}}$$又因为$C_n^m&#x3D;C_n^{n-m}$所以：$$\\sum_{i&#x3D;0}^{c}{C_c^i(k-1)^{c-i}}&#x3D;\\sum_{i&#x3D;0}^{c}{C_c^i(k-1)^{i}}$$证毕。\n不过这东西有啥用处嘞？\n其实可以发现外层的$\\sum_{i&#x3D;0}^{c}$就是在枚举这个大小为$c$的点集的子集大小，而$C_c^i$则是表示这样大小的子集有多少个，这下就可以光明正大的把一个状态的子集全算一遍了，只需要把贡献里的$k$变成$k-1$即可。","title":"树上容斥","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/10/12/DP/树上背包/","tags":[],"text":"","title":"树上背包","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/10/12/数学/线性基/","tags":[],"text":"啥事线性基？如果你去看了OIwiki上的解释，恭喜你，你肯定是没看懂才来看我的，\n没错，那些解释的鸟语并没有什么用，它主要是用于解决带异或这种操作的一系列问题的，诸如什么“边权异或值最短路”等。\n其实这就像一个只能做二进制下不进位加法的高斯消元，只不过是没有式子最后等于的值，只去削系数，我们希望让他最好是像高斯消元那样每一个系数自己单出来其他位尽量是0，这样可以利于我们更好的去用这个“自由位”掌控我们想让他异或成的数，无论是变得最大还是最小，\n所以我们的策略是先让大一点的位自由，那每次往这个“备选库”里加入一个数的时候先用之前原有的数把它消到能被消到的最小值，如果不是0，再以他作为它最高位那一位的“基准”，顺便再去把其他比他大的位的“基准”消到新的最小值，而这个操作是肯定不会把原有基准变的不合法的，只会使那个“基准”逐渐趋近直至等于它最高位的二的幂次，而这时这个位就彻底自由了，当然不自由也无所谓，照样用：\n比如你有这么一个库，以及一个你想让他异或随便一些库里的数变得最小，那你就可以看这个位是不是1，若是，就异或上，因为后面增大的再多比不上最高位没掉，否则就不，想让他变最大也是同理。","title":"线性基","updated":"2025-09-05T13:37:49.444Z"},{"categories":[],"path":"2023/10/12/杂题选讲/A/","tags":[],"text":"什么是A*？启发式搜索。那这回答说了和没说一样，对新学的人总不能讲术语吧，这样谁能听懂呢？是这个道理吧。不过这不是第一次遇到“启发式”了上一次是dsu on tree，那什么是启发式呢？就是贪啊，说白了，就是一些符合人最浅显逻辑的优化。那回到正题，A是啥？学过dijkstra没？学过？那就完事了。A本质上和dij是一样的，就是每次挑当前最优的去更新别的，没了，真的没了，讲完了，正题就那么几句人话，其他全是水字数的就是用的时候看一下有妹有限制性，注意细节就行。","title":"A*","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/10/12/杂题选讲/一个DP套路/","tags":[],"text":"题目描述简述：给一些物品，两维重量，一维价值，求取一些物品满足第一种重量和不大于$P$，第二种重量和不小于$P$时，价值的最小值$n\\le1e3,P\\le1e5$。这东西我第一眼看甚至都不敢保证$nP$能不能过，后来发现我弱到只能写$nP^2$。暴力自然比较好想，就是开三维，一维下标，二维重量一，三维重量二，内容存最小价值。咋做到$nP$呢，看到限制里面有$0\\le b_i\\le a_i\\le 1e6$，想一下，有什么用处？既然$a$的和蹭线就行$b$的和不过线就行，那我们其实可以通融通融，把它们的值向中间收束，反正他俩只是状态，和答案的值没关系，过线的部分少一点不影响他已经过线的事实，没过的部分多一点也不影响他没过的状态，这样我们就可以把两个状态合并，把一个物品当成一组物品，每组物品至多取一个，物品只有一个重量，组内价值都是原来物品的价值，物品的唯一重量在组内恰好把$[b_i,a_i]$这个区间覆盖一遍，这样一来，再按类似原来的方法$dp$，只不过一维下标，二维重量，内容存价值。这么看好像还不够，毕竟区间一大就又完蛋，但其实不是，单调队列维护区间最小值，设当前遍历到的物品是$i$已达的重量是$j$，那么转移就是$$f[i][j]&#x3D;min(f[i-1][j],\\min^{j-b[i]}_{k&#x3D;j-a[i]}(f[i-1][k]+c[i]))$$最终答案就是$f[n][P]$，因为按上面的方法拆完物品后，一定会有合法最优解卡在$P$\n总结：算是一种套路吧，就有一种只用满足状态的大于小于关系的可以为了优化时间来在规则允许的情况下收束来减少状态数。（可能有什么神展开但我智力有限一时半会无法想象，等以后遇到类似的再说吧）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define gtc() getchar()#define fp(i,l,r) for(int i=l;i&lt;=r;i++)#define fb(i,l,r) for(int i=l;i&gt;=r;i--)#define pil pair&lt;int,long long&gt;template &lt;class T&gt;inline void read(T &amp;s)&#123; T neg=1,ch=gtc();s=0; while(!isdigit(ch))&#123;if(ch==&#x27;-&#x27;)neg=-1;ch=gtc();&#125; while(isdigit(ch))&#123;s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch-&#x27;0&#x27;);ch=gtc();&#125; s=s*neg;&#125;const ll N=1000050;ll t,n,m,a[N],b[N],c[N],ans=1e18,l,r,f[2][N];struct node&#123; ll v,p;&#125;tmp,deq[N];int main()&#123; clock_t st,ed; st=clock(); freopen(&quot;shop.in&quot;,&quot;r&quot;,stdin); freopen(&quot;shop.out&quot;,&quot;w&quot;,stdout); read(n),read(m); fp(i,1,n)read(a[i]); fp(i,1,n)read(b[i]); fp(i,1,n)read(c[i]); fp(i,1,m)f[0][i]=f[1][i]=1e18; fp(i,1,n)&#123; l=r=1; fp(j,1,m)&#123; if(j-b[i]&gt;=0)&#123; while(r&gt;l&amp;&amp;deq[r].v&gt;f[(i%2)^1][j-b[i]])r--; deq[++r].p=j-b[i],deq[r].v=f[(i%2)^1][j-b[i]]; while(deq[l+1].p&lt;j-a[i])l++; //cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;j&lt;&lt;&quot; &quot;&lt;&lt;deq[l+1].p&lt;&lt;&quot; &quot;&lt;&lt;deq[l+1].v&lt;&lt;endl; f[i%2][j]=min(f[(i%2)^1][j],deq[l+1].v+c[i]); &#125; f[i%2][j]=min(f[i%2][j],f[(i%2)^1][j]); &#125; &#125; printf(&quot;%lld&quot;,f[n%2][m]); ed=clock(); //cout&lt;&lt;endl&lt;&lt;ed-st; return 0;&#125;","title":"一个DP套路","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/10/12/杂题选讲/小技巧（7）/","tags":[],"text":"求完阶乘求他们的逆元会T？会正着乘求阶乘不会倒着乘把分母从大到小消掉吗？\n12345fac[0]=1;fm[0]=1;fp(i,1,n)fac[i]=fac[i-1]*i%mod;//阶乘fm[n]=qp(fac[n],mod-2);fb(i,n-1,1)fm[i]=fm[i+1]*(i+1)%mod;//逆元","title":"小技巧（7）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/10/12/杂题选讲/小技巧（8）/","tags":[],"text":"swap的原理是换指针，所以无论换啥都是$O(1)$","title":"小技巧（8）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/10/12/杂题选讲/小技巧（9）/","tags":[],"text":"维护线组成的凸包？按k排完序后：思路1：k b 转 x y ，维护点；思路2：看与隔一个之前的线的交点在前一个与隔一个之前的交点的前还是后。\n最正确与简单的数论分块方法：\n1234567l=1,r;while(l&lt;=n)&#123; r=n/(n/l); ......//对l~r这个区间进行操作 ...... l=r+1;&#125;","title":"小技巧（9）","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/10/12/杂题选讲/高维前缀和/","tags":[],"text":"","title":"高维前缀和","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/10/12/杂题选讲/错误合集/","tags":[],"text":"多测不初始化\n链式前向星建图cnt未初始化为1\n循环内i、j用混","title":"错误合集","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/10/12/杂题选讲/玄学-非玄学技巧/","tags":[],"text":"非玄学部分正解的出现绝大多数情况下除了本身熟练了无需多想以外，就是枚举可能正确的做法。\n离线？如果要处理多个询问，只要不强制在线，一定要提醒自己：可以离线！可以离线！！可以离线！！！，离线后排序可能会导致复杂度骤降！！！\n正难则反？正着跑、倒着跑、正着跑正着算、倒着跑倒着算，别都已经倒着跑了还正着算，可能会使你的复杂度从$O(n)$飙升至$O(n!)$例：一个教训\n代码能短就短，最令人难受的就是像写大数据结构一样的代码，原因主要并不是害怕写长代码，而是短代码确实好看，而且易于挑错，平时积累一些奇技淫巧用上也无所谓，只要比赛能用，自己能快速懂，再奇怪也无所谓。\n一元排序处理出来是错的？试试二元排序，比如按a和b的max、min、+、-、*、&#x2F;……例：按max\n图上期望只会解方程？却发现三方会T？试试推式子，觉得是无穷循环嵌套？自己调用自己为什么不能直接在等式另一边直接用自己呢？比如\n$$X_i&#x3D;P_iA+P_i(1-P_i)A+P_i(1-P_i)^2*A+…$$\n可以转化为\n$$X_i&#x3D;P_i*A+(1-P_i)*X_i$$\n(来自于例题的官方题解)\n卡常吗？$scanf$和$printf$其实不慢，快读并不能解决大问题，实际上要注意的是：剪枝：这就是看情况。取模：主要是如果不爆$longlong$就少取模，像加法什么的，最后总起来取一个就好了，甚至可以判断大于模数就减，至于乘什么的，超过俩相乘就还是要取模的。最关键的不能算是卡常而是优化复杂度的——预处理阶乘、逆元等做到$O(1)$查询来省去一个$log$。\n更好的替代品$ddp$的核心就在于他的线段树维护矩阵乘法上，得已支持快速修改和查询，有妹有什么比矩阵更快的呢？其实是有的，对于一些每一位的转移都相同且有交换律的，我们有——生成函数，听着挺高大上，就是多项式，$FFT$啥的可以快速维护，不过暴力卷也是不劣的，至于更改，就是递推或者解方程，也没啥好说的，不过时间和空间都优了不少。\n玄学部分每隔$30min$~$1h$就去上个厕所、洗把脸，可能会有灵感\n训练的时候总是感觉状态不好，合理的睡眠是很重要的，既不能睡多，也不能睡少，适量熬夜第二天会很精神。","title":"玄学&非玄学技巧","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/10/12/数据结构/“线段树分治”/","tags":[],"text":"这玩意其实并没有那么广义，就像“分治”或“线段树上二分”，这玩意其实是用于解决 “图中的边在一个时间区间内生效” 类的问题的。\n就是用开在时间上的线段树维护边，把边挂在它覆盖的区间上，最后遍历线段树，进一个树上的点就把上面的边全暴力连上，出去的时候再全断开，一般来说常常和可撤销并查集一起用 （至少本人见过的都是），用于维护连通性或特定的大小或图符合什么奇奇怪怪的性质。\n例：nfls\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long #define gtc() getchar()#define fp(i,l,r) for(int i=l;i&lt;=r;i++)#define fb(i,l,r) for(int i=l;i&gt;=r;i--)#define pil pair&lt;int,long long&gt;template &lt;class T&gt;inline void read(T &amp;s)&#123; T neg=1,ch=gtc();s=0; while(!isdigit(ch))&#123;if(ch==&#x27;-&#x27;)neg=-1;ch=gtc();&#125; while(isdigit(ch))&#123;s=(s&lt;&lt;3)+(s&lt;&lt;1)+(ch-&#x27;0&#x27;);ch=gtc();&#125; s=s*neg;&#125;const ll N=1000050;ll n,m,k,top,ans,stk[N];struct node&#123; ll p,v;&#125;;struct edge&#123; ll u,v,w;&#125;e[N];vector&lt;int&gt; nd[N],rb[N];struct DSU&#123; ll fa[N],sz[N]; ll find(ll x)&#123;return fa[x]==x?x:find(fa[x]);&#125; ll init()&#123;fp(i,1,1000000)fa[i]=i,sz[i]=1;&#125; void merge(ll x,ll y,ll ad)&#123; ll fx=find(x),fy=find(y); if(fx==fy)return ; if(sz[fx]&lt;sz[fy])swap(fx,fy); //cout&lt;&lt;&quot;mer&quot;&lt;&lt;ad&lt;&lt;&quot; &quot;&lt;&lt;fx&lt;&lt;&quot; &quot;&lt;&lt;sz[fx]&lt;&lt;&quot; &quot;&lt;&lt;fy&lt;&lt;&quot; &quot;&lt;&lt;sz[fy]&lt;&lt;endl; stk[++top]=fy; if(ad)ans+=sz[fx]*sz[fy]; fa[fy]=fx; sz[fx]+=sz[fy]; &#125;&#125;dsu;void add(ll x,ll l,ll r,ll tl,ll tr,ll v)&#123; if(l&gt;=tl&amp;&amp;r&lt;=tr)&#123; nd[x].emplace_back(v); return ; &#125; ll nxt=x&lt;&lt;1,mid=(l+r)&gt;&gt;1; if(tl&lt;=mid)add(nxt,l,mid,tl,tr,v); if(tr&gt;mid)add(nxt+1,mid+1,r,tl,tr,v);&#125;void dfs(ll x,ll l,ll r)&#123;//cout&lt;&lt;&quot;x &quot;&lt;&lt;l&lt;&lt;&quot; &quot;&lt;&lt;r&lt;&lt;endl; ll now=top; for(auto i:nd[x])&#123;/*cout&lt;&lt;i&lt;&lt;endl;*/dsu.merge(e[i].u,e[i].v,0);&#125; if(l==r)&#123; for(auto i:rb[l])&#123;/*cout&lt;&lt;i&lt;&lt;endl;*/dsu.merge(e[i].u,e[i].v,1);&#125; &#125; else&#123; ll nxt=x&lt;&lt;1,mid=(l+r)&gt;&gt;1; dfs(nxt,l,mid); dfs(nxt+1,mid+1,r); &#125; while(top&gt;now)dsu.sz[dsu.fa[stk[top]]]-=dsu.sz[stk[top]],dsu.fa[stk[top]]=stk[top],top--; nd[x].clear();&#125;ll sol(ll len)&#123; ans=0; fp(i,1,n-1)if(e[i].w+1&lt;=n)add(1,1,n,e[i].w+1,min(n,e[i].w+len),i);//,cout&lt;&lt;i&lt;&lt;&quot; &quot;&lt;&lt;e[i].w+1&lt;&lt;&quot; &quot;&lt;&lt;e[i].w+len&lt;&lt;endl; fp(i,1,200000)dsu.fa[i]=i,dsu.sz[i]=1; dfs(1,1,n); return ans;&#125;int main()&#123; freopen(&quot;minmax.in&quot;,&quot;r&quot;,stdin); freopen(&quot;minmax.out&quot;,&quot;w&quot;,stdout); read(n),read(k); fp(i,1,n-1)&#123; read(e[i].u),read(e[i].v),read(e[i].w); rb[e[i].w].emplace_back(i); &#125; printf(&quot;%lld&quot;,sol(k)-sol(k-1)); return 0;&#125;\n时间复杂度$O(nlognlogk)$","title":"“线段树分治”","updated":"2025-09-05T13:37:49.444Z"},{"categories":[],"path":"2023/08/14/DP/LCIS/","tags":[],"text":"是个模板，不是非常大的一个知识点，最长上升公共子序列，直接说最快做法N^2吧，就是外循环i枚举第一个数组里遍历到的下标，内循环j枚举第二个数组里遍历到的下标，f[i][j]存a遍历到i,b遍历到j时的最长上升公共子序列长度，如果a[i]!&#x3D;b[j],f[i][j]&#x3D;f[i-1][j]，显然因为i对答案没有贡献，所以加不加他都一样，如果a[i]&#x3D;&#x3D;b[j],f[i][j]&#x3D;max(f[i-1][k])+1,k&lt;j,就是从前面找一个最大的转移，这就比较显然了，每次进行一遍内循环就计一次内循环里之前遇到的b[j]值小于a[i]值的最大f[i-1][j]，如果遇到a[i]&#x3D;&#x3D;b[j]就把f[i][j]更为记录的那个值+1，正确性有保证因为前面记录的是合法的f值，也就是每一位都相互对应，而且算进答案的b[k]只有比a[i]小的，自然与b[k]相等且对应的a[l]比a[i]小，b[k]也比等于a[i]的b[j]小，如此得到的答案依然合法。\n12345678for(int i=1;i&lt;=n;i++)&#123; ll tmp=0; for(int j=1;j&lt;=m;j++)&#123; f[i][j]=f[i-1][j]; if(b[j]&lt;a[i])tmp=max(tmp,f[i-1][j]); if(a[i]==b[j])f[i][j]=tmp+1; &#125;&#125;\n很简短，这就没了 顺带一提，最长上升子序列有个lower_bound做法，但我更喜欢值域线段树在线维护区间最大值，线段树上存的是以下标为结尾的最长长度，求答案就query前缀就好了，然后再把当前的答案再插回去，没准魔改一下树状数组可以去除大常数的问题。\n最长公共子序列好像只有N^2?","title":"LCIS","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/08/14/生活杂记/diary/8-14/","tags":[],"text":"最有意思的是我网络流写了那么多遍居然全是错的，可是还都过了，记住边不流满不要跳边不流满不要跳边不流满不要跳这是两个下午的教训。用两个下午换来我以后别再错……也行吧……","title":"8-14","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/13/生活杂记/diary/8-13/","tags":[],"text":"接8-10，也别太相信一些东西，尤其不要对自己蒙混过关，譬如拿一些东西来糊弄自己，纵使自己不想，这种情况还是会在你自己不知情的情况下出现，但也别浪费太多时间。总之，自己平衡证明的浪费时间比吧。另外，别太相信一些经验，也别太不信一些经验，自己看着办，真是啥都有道理，我也没法解释，我也没法说啥对。就这样吧~","title":"8-13","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/13/生活杂记/thoughts/梁老师生日特辑/","tags":[],"text":"","title":"梁老师生日特辑","updated":"2025-09-05T13:27:46.052Z"},{"categories":[],"path":"2023/08/11/图论/2-SAT/","tags":[],"text":"","title":"2-SAT","updated":"2025-09-05T13:37:49.444Z"},{"categories":[],"path":"2023/08/11/图论/欧拉路径/","tags":[],"text":"","title":"欧拉路径","updated":"2025-09-05T13:37:49.446Z"},{"categories":[],"path":"2023/08/11/字符串/AC自动机/","tags":[],"text":"","title":"AC自动机","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/08/11/字符串/KMP/","tags":[],"text":"","title":"KMP","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/08/11/杂题选讲/小技巧（6）/","tags":[],"text":"批量的区域性建边太多怎么办？线段树优化建图。当然，因为是有向图，一棵向父亲连边，每个节点连向带他下标的叶子，一棵向儿子连边，最终叶子连向下标的节点。（视情况决定动态开点、是否省略其中一棵树）\n发现了一个规律，没什么算法的矩阵上的题，往往会把前缀某、后缀某、上缀某、下缀某都先预处理一下，（后俩名字是我瞎编的）然后再搞单调队列？常见套路了。\n遇见一些操作是分裂、断边的不好办？试一试先全处理完，之后再慢慢并回去、连回去，会好做一点？\n搜索太垃圾？剪枝也不行？试试看折半行不行，本质上还是枚举，但是确实可以优化，\n状态存不下怎么办？别忘了map一类哈希表是你的好兄弟，实在不行手写嘛~（模数选的好，就能快不少）","title":"小技巧（6）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/08/11/杂题选讲/折半搜索/","tags":[],"text":"","title":"折半搜索","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/08/11/生活杂记/diary/8-10/","tags":[],"text":"话说只更日记不写点知识点是不是也算偷懒？估计是吧，那不更这么勤了（逃~下回有时间就写点记录知识点的吧，杂题选讲这东西，我发现貌似记得东西要么熟的不行，要么也根本想不到之前还能记过，就这样吧。（尝试去肝出一点有实际意义的东西）pls：把一些本来写在知识点里的写在这了：这里要说一下，（对于一个知识点）既然你都知道他是正确的了，就少去怀疑它的正确性，有了疑问先别大胆质疑它是错的，先想想怎么破除自己的疑问，当然也别不了了之，实在不行，问嘛~又不是说多耻辱一件事，再耻辱不过失败了耻辱，对吧？","title":"8-10","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/11/生活杂记/diary/一份临时的任务告示（做完即撤）/","tags":[],"text":"这是我写给自己这几天看的，朋友们可以先撤了~\n我说，看见那些空白的专题了吗？所以你知道该怎么做了吧。怕你忘了，下面是任务单：\n欧拉路径2-SAT连通性专题折半搜索AC自动机KMP\n先这些吧，写完一个删一个。","title":"一份临时的任务告示（做完即撤）","updated":"2025-09-05T13:37:49.452Z"},{"categories":[],"path":"2023/08/09/杂题选讲/小技巧（5）/","tags":[],"text":"12345678ll lca(ll x,ll y)&#123; if(dep[x]&lt;dep[y])swap(x,y); ll cd=dep[x]-dep[y]; for(int i=0;cd;i++,cd&gt;&gt;=1)if(cd&amp;1)x=fa[x][i]; for(int i=25;i&gt;=0;i--)if(fa[x][i]!=fa[y][i])x=fa[x][i],y=fa[y][i]; if(x!=y)x=fa[x][0]; return x;&#125;\n可以给倍增求lca提提速","title":"小技巧（5）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/08/09/生活杂记/diary/8-4/","tags":[],"text":"日记高产月（bushi按理说，日记不就应该每天都写才对嘛~是不是该注意一下明年再写日记标题就要带年份了，hmm~（水日记ing企图蒙混过关）过不过关还是我自己说了算啊↓，感觉自己也太弱了吧，立个flag好吧，从明天开始模拟赛目标就是最多只剩一题不A！（说和做还是有区别的）但是尽量吧（三小时挑战一下好吗？吕华子乱入而且从明天开始补题也尽量在6点前补完，后面留出时间补更之前的题，直到全补完，然后再做点别的题，写点blog，记一点更水的日记","title":"8-4","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/09/生活杂记/diary/8-9/","tags":[],"text":"怎么说，不怎么想更日记更的的太快了一方面是我实在找不到什么值得去记的素材，再一方面……\n我太懒了。\n不过既然szh催更了，那我还是写写吧，是该好好反思一下最近为什么既不记知识点又不更日记了，难道真是因为都学会了没需要特意记的、没素材吗？不尽然吧，要不为啥最开始的时候写的好好的，高产的时候能一天两三篇，还是懈怠了，对吧？先原谅之前的所作所为吧，毕竟摆下去也不是办法，从明天起别再颓废了就行。\n水内容到此为止 今天怎么说呢，比较轻松愉快的一天，讲的内容没难度，题的码量也不大，难得的很友善啊，回想起前两天的噩梦，简直是天差地别。\n时间业已过半，不知道为什么，这些天来一直有两种感觉在交错——一种是“时间为什么流逝的这么慢，太煎熬了”，另一种是“为啥感觉时间过的这么快，题还没调几道&#x2F;知识点还没学多少，就只剩一半的日子了”。\n不评价了吧，这东西，每个人都可能有的感受，我也不好说是什么原因，又或有什么启示，就这样吧。","title":"8-9","updated":"2025-09-05T13:27:46.059Z"},{"categories":[],"path":"2023/08/04/生活杂记/diary/8-3/","tags":[],"text":"byd以后日记都成昨天记了是吧（fog平凡而又不是很有作为的一天，只是把题补完而已，并没有收获很多……凌晨才睡更失败，最后一题依旧补的很水。","title":"8-3","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/03/生活杂记/diary/8-2/","tags":[],"text":"算是补一下昨天的日记吧~","title":"8-2","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/01/生活杂记/diary/8-1/","tags":[],"text":"好久没写日记了~（希望下次别是这个开头 平凡的一天，没怎么多做题，补完全部了，不过最后一个略微水过去了，感觉即使这样依旧有点浪费时间，可能是和yty&amp;szh重逢的缘故吧……前途不怎么光明啊！下一级和同级没出现的人才本就很多，今年参加国赛的又有足足15人明年还要打，还不包括女队……不，我可不相信这就是一切的终结，至少不是在这，不是在这OI生涯里……做好准备吧！！！（改编自BattleFieldⅠ行动模式-阿尔贡森林守军）明天别忘了继续写日记啊","title":"8-1","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/08/01/生活杂记/The most important/hi-my-“dear”-friend/","tags":[],"text":"你想看？那你可必须是——","title":"hi~my “dear” friend","updated":"2025-09-05T13:27:46.052Z"},{"categories":[],"path":"2023/08/01/杂题选讲/小技巧（4）/","tags":[],"text":"$lowbit(x)&#x3D;x&amp;(-x)$$x&amp;(x-1)&#x3D;x\\quad xor\\quad lowbit(x)$\n1234for(int i=x;;i=(i-1)&amp;x)&#123; ... if(i==0)break;&#125;\n可枚举$x$在二进制下的子集","title":"小技巧（4）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/07/31/杂题选讲/小技巧（3）/","tags":[],"text":"如何应对大量的质因数分解的询问？如果数的大小小于$1e7$的话可以考虑先线性筛一把，再利用线性筛的$v$数组来一点一点除，单个查询复杂度跑满是$log$的。\n一个结论——有根树上一个点与一个点集内这个点的$dfn$序的前驱或后继形成的$lca$的深度是点集内所有点与之形成的$lca$中深度最大的。\n又一个结论查字符串循环节可以考虑枚举循环节大小，对总串的长度做质因数分解，挨个质因数试，看除了以后是否还为循环节，若查询为$O(1)$则总时间复杂度为$O(log(n))$","title":"小技巧（3）","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/07/21/DP/斜率优化/","tags":[],"text":"何时使用斜率优化？当$dp$的状态转移方程可以转换成形如$f_i&#x3D;max&#x2F;min(y_j+k*x_j)_{(j&lt;i)}$的形式时，可以构造凸包来维护对于每一个$i$最优的决策点$j$\n凸包的维护维护一个双端队列，\n比如需维护上凸包时，新加进的点如果和队尾点形成直线的斜率大于等于队尾两个点的斜率，就需要弹出队尾，重复这一过程直到小于或者队内只有一点，最后再加入新点。\n下凸包也一样。\n值得注意的是，由于除法有精度损失，所以比较时可以采用移项转乘法来精确比较。\n如何判断需要维护上凸包还是下凸包？推式子，\n比如如果状态转移方程是$f_i&#x3D;max(y_j+k*x_j)_{(j&lt;i)}$，那对于$x_a&lt;x_b&lt;x_c$三个决策点，因为$b$有作为某些询问最优转移点的时刻，所以对于这些时刻的$k$有:\n$$y_a+kx_a&lt;y_b+kx_b$$\n$$y_c+kx_c&lt;y_b+kx_b$$\n移项得：\n$$-k&lt;\\cfrac{y_b-y_a}{x_b-x_a}$$\n$$-k&gt;\\cfrac{y_c-y_b}{x_c-x_b}$$\n这也就说明我们需要维护的是一个上凸包，因为只有在$-k$比$ab$线的斜率小、比$bc$线的斜率大时，取$b$为转移点才是最优的；若$bc$线的斜率大于等于$ab$线的斜率，则使$b$点为最优决策点的$k$的取值范围为空集，那么$b$也就不是一个决策点。\n$min$的时候也是同理。\n如何回复询问？询问应当是单调的，而且与凸包的单调性相匹配，比如上凸包对应的$-k$的单调性应为单调下降，下凸包则相反，查询即从队头开始，比如上凸包，若队头的线对应斜率大于$-k$，则应弹出队头，直到小于或队中只有一点，此时用队头的点作为最优决策点计答案即可。反之亦然。\nps:斜率不单调怎么办？其实可以，维护组成凸包的点时用数组模拟双端队列，既然里面的斜率是单调的，那就可以二分找到第一个计答案比后一个点优的点，它必然是最优转移点\n几个例题平面中有$n$个点$(x_i,y_i)$，有$m$条直线，斜率$k$已经确定，需要在给定的$n$个点中，选出一个点$(x_i,y_i)$，使得$kx+y$最大。\n单纯维护斜率和查询，直接上代码：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long ll n,m,ans[100050];struct node&#123;\tll x,y;\tbool operator &lt;(const node &amp;a)const&#123; return x&lt;a.x||(x==a.x&amp;&amp;y&gt;a.y);\t&#125;&#125;p[100050],pre1,pre2;struct query&#123;\tll pos,k;\tbool operator &lt;(const query &amp;a)const&#123; return k&gt;a.k;\t&#125;&#125;q[100050];deque&lt;node&gt; st;int main()&#123;\tscanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);\tfor(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld%lld&quot;,&amp;p[i].x,&amp;p[i].y);\t&#125;\tsort(p+1,p+1+n);\tfor(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%lld&quot;,&amp;q[i].k); q[i].pos=i;\t&#125;\tsort(q+1,q+1+m);\tfor(int i=1;i&lt;=n;i++)&#123; if(st.size()&lt;2)&#123; if(st.size()&gt;0)&#123; if(p[i].x==st.front().x)&#123; if(p[i].y&gt;st.front().y)st.pop_front(); else if(p[i].y&lt;=st.front().y)continue; &#125; &#125; st.push_back(p[i]); continue; &#125; ll pd=1; while(st.size()&gt;=2)&#123; pre1=st.back(); st.pop_back(); pre2=st.back(); st.pop_back(); if((double)(p[i].y-pre1.y)*(pre1.x-pre2.x)&lt;(double)(pre1.y-pre2.y)*(p[i].x-pre1.x))&#123; st.push_back(pre2); st.push_back(pre1); st.push_back(p[i]); break; &#125; else&#123; st.push_back(pre2); &#125; &#125; st.push_back(p[i]);\t&#125;\tll cnt=m;\twhile(cnt&gt;0&amp;&amp;st.size()&gt;1)&#123; pre1=st.front(); st.pop_front(); pre2=st.front(); if(-q[cnt].k*(pre2.x-pre1.x)&gt;(pre2.y-pre1.y)) ans[q[cnt].pos]=pre1.x*q[cnt].k+pre1.y,st.push_front(pre1),cnt--;\t&#125;\twhile(cnt&gt;0)&#123; pre1=st.front(); ans[q[cnt].pos]=pre1.x*q[cnt].k+pre1.y; cnt--;\t&#125;\tfor(int i=1;i&lt;=m;i++)printf(&quot;%lld\\n&quot;,ans[i]);\treturn 0;&#125; Kano准备扩大他的农场，眼下必须购买$N\\le5e4$块长方形土地。如果Kano买一块土地，价格就是土地的面积。他也可以选择并购多块土地，并购的价格为这些土地中最大的长乘以最大的宽，比如Kano购买$35$和$53$的土地，只需要支付$5*5&#x3D;25$元，比分开买合算。请你帮他计算购买所有土地的最小费用。\n首先一个显然的性质是如果对于一块地有另一块地长宽均大于等于它，那它可以直接与那一块合并而不付出任何代价；其次，我们对清除完合并无需付出代价的地块后，按长单增排序，宽也就会按从大到小排好，甚至是单调减而非单调不上升，根据前一个性质即可得到；排序后我们可以得到一个$dp$状态转移方程：$f_i&#x3D;min(f_j+w_{j+1}*l_i)_{j&lt;i}$其中$w$为宽，$l$为长，往上面套套路即可。值得注意的是，这个凸包是以$x$从大到小造的，所以维护的时候还需思考它的判断式子该怎么写。\n1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long ll n,cnt,l=0,r=0,f[100000];struct node&#123; ll x,y; bool operator &lt;(const node &amp;a)const&#123; return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y); &#125;&#125;c[100000],b[100000];struct point&#123; ll x,y;&#125;p[100000],tmp;int main()&#123; scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld%lld&quot;,&amp;c[i].x,&amp;c[i].y); &#125; sort(c+1,c+1+n); for(int i=1;i&lt;=n;i++)&#123; while(cnt&gt;0&amp;&amp;b[cnt].x&lt;=c[i].x&amp;&amp;b[cnt].y&lt;=c[i].y)cnt--; b[++cnt]=c[i]; &#125; tmp.x=b[1].y; tmp.y=0; p[++r]=tmp; for(int i=1;i&lt;=cnt;i++)&#123; while(r-l&gt;1&amp;&amp;-b[i].x&lt;=(p[l+2].y-p[l+1].y)/(p[l+2].x-p[l+1].x))&#123; l++; &#125; f[i]=p[l+1].x*b[i].x+p[l+1].y; tmp.x=b[i+1].y; tmp.y=f[i]; while(r-l&gt;1&amp;&amp;(tmp.y-p[r].y)*(p[r].x-p[r-1].x)&gt;=(p[r].y-p[r-1].y)*(tmp.x-p[r].x))&#123; r--; &#125; p[++r]=tmp; &#125; printf(&quot;%lld&quot;,f[cnt]); return 0;&#125; 玩具装箱这题不难得到状态转移方程$f_i&#x3D;min(f_j+(i-j-1-L+\\sum^{i}{k&#x3D;j+1}c_k)^2){(j&lt;i)}$,但这个式子比较抽象不好看，可以转换一下，把区间和变成前缀和相减的形式，再把前面加与减的$i$和$j$正好按同符号放进去，可得$f_i&#x3D;min(f_j+(sum_i-sum_j-L-1)^2){(j&lt;i)}$，再把与$j$有关和无关的拆分整理可得$f_i-(sum_i-L-1)^2&#x3D;min(f_j+sum_j^2-2*(sum_i-L-1)*sum_j){(j&lt;i)}$,这时候再套板子就行了，和前一个题一样，这个也是倒着造凸包。\n123456789101112131415161718192021222324252627282930313233#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long ll n,L,f[100050],sum[100050],l=0,r=0;struct node&#123; ll x,y;&#125;p[100050],tmp;int main()&#123; scanf(&quot;%lld%lld&quot;,&amp;n,&amp;L); L++; for(int i=1;i&lt;=n;i++)&#123; scanf(&quot;%lld&quot;,&amp;sum[i]); sum[i]+=sum[i-1]+1; &#125; tmp.x=0; tmp.y=0; p[++r]=tmp; for(int i=1;i&lt;=n;i++)&#123; ll k=sum[i]-L; while(r-l&gt;1&amp;&amp;-k&lt;=(p[l+2].y-p[l+1].y)/(p[l+2].x-p[l+1].x))&#123; l++; &#125; f[i]=k*k+p[l+1].y+p[l+1].x*k; tmp.x=-2*sum[i]; tmp.y=f[i]+sum[i]*sum[i]; while(r-l&gt;1&amp;&amp;(tmp.y-p[r].y)*(p[r].x-p[r-1].x)&gt;=(p[r].y-p[r-1].y)*(tmp.x-p[r].x))&#123; r--; &#125; p[++r]=tmp; &#125; printf(&quot;%lld&quot;,f[n]); return 0;&#125; 第一次修订：增加了关于查询非单调的处理方法。","title":"斜率优化","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/07/17/杂题选讲/小技巧（1）/","tags":[],"text":"DP瓶颈解决思路有些时候我们可能会遇到在dp中状态开不下的问题，可以考虑把状态和存储内容互换，尽可能使状态简洁，同时不要过快否决转换的思想，正确性的证明？ （打完比赛再说，说不定试出来是对的呢） 除了知识储备还是要对自己有一点信心。\n例：接下来$n(1\\le n\\le 2000)$天，每天有$a_i(1\\le a_i\\le 5*10^5)$场比赛。\n如果截止到第$i-1$天的胜率小于第$i$天的胜率，乐乐就会在第$i$天心情变得更好。否则，他的心情会变得更糟。其中，第$i$天的胜率指的是，当$i&#x3D;0$时为$0$，否则指的是第$i$天之前玩游戏赢的次数总和除以第$i$天之前玩游戏的次数总和所得的值。\n已知这$n$天，总共赢了$K(0 \\le K\\le \\sum a_i)$次。求乐乐最多能开心多少天。\n正常这题我们能想到开二维：第一维表示当前天数，第二维表示使用胜利数，存储的是最多快乐天数。\n那这复杂度显然没法接受，其实我在赛时就想到了把存的最多快乐天数变成第二维“快乐天数”，之前的第二维变成存储的“达成最少使用的胜利数”，但我很快就意识到了他的正确性问题——他不一定是单调的（即有时候用的胜利数多了可能反而快乐天数少了），因此赛时我就陷入了瓶颈，最终没能切掉。\n其实最后再观察观察，用不等式的一些变换就可以得到“真分数分子分母同加值会变大”这一结论，那只要他达不到1，如果拥有的胜利数多于最少需要的，我们尽可能把他往后堆，一旦先填满后面的几天，他的值就绝对是单增的，因此特判1的情况后他的正确性就可以保证了，至于1的情况那就只会快乐1天因为一直相等。\n数量级小结论把一个数划分成若干数的不同方案数我们称之为划分数，30的划分数在2000左右，50的划分数在$2*10^6$左右\n图上小结论有些时候我们可能需要求一棵树上的一个连着某些点的这么一个连通分量的大小，那我们可以考虑按随意顺序但是单环状求一遍两点之间路径（注意并非两两之间路径），即求包含$a_1,a_2,a_3…a_n$的连通分量的边数，我们可以求$a_1a_2,a_2a_3,a_3a_4…a_{n-1}a_n,a_na_1$之间的的路径数之和再除2（因为每条边刚好被算两遍），点数则为边数+1。\n例：\n给定一棵树，节点有编号，给最大边数，求连续编号在同一边数不超过最大边数的联通块的最多连续编号数量。\n考虑尺取法，即一个一个点加入联通块，记录$ans&#x3D;总边数2$的值，加入时选新加点$u$在树上DFN序的前驱和后继（最后与最前互为前驱和后继），$ans+&#x3D;Dis_{pre,u}+Dis_{u,nxt}-Dis_{pre,nxt}$，除去点时同理只需把符号反转，ans为总边数2的性质依然成立。\n正确性？\ndfs时它走的顺序都是“前-x-后”，那它自然不会重复加一段已经加两遍且没被删一次的边（图为错误示范，即从已有红点选中绿点的并非黄点DFN序的前驱和后继，红边为原有加入的边，紫边为删掉的边，灰边为新加的边，棕边为重复加的边）","title":"小技巧（1）","updated":"2025-09-05T13:37:49.448Z"},{"categories":[],"path":"2023/07/17/杂题选讲/小技巧（2）/","tags":[],"text":"APIO 2014 连珠线这道题的难点在于完全掌握题意，最开始我以为它的意思是“一个节点最多只能当一个连续两蓝线的中点”，但实际上这么理解就会出问题，因为它的原始题意说的是只允许插入单个珠子，而“工”字形的构造在这时就会发现不可能出现，因为它意味着一定会有两段珠子的中心直接或间接相连接的这一过程，其实我一开始过度理解题目了，可以尝试带一点模拟思想去看，就是从根向下不断加珠子，新加进来的珠子有可能是日后的中点，也有可能并不是，而所有的连蓝段也就全是“祖-父-孙”型的了，但是注意到在根不同的情况下，之前不存在的“兄弟”型可能在另一种情况下存在了，所以我们应当对所有节点为根的情况挨个求其最优结果并取最大值，由于它的根与根之间的转移比较好处理，所以可以换根DP\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long ll n,f[300000][2],head[300000],cnt=1,ans,lian[300000][2],son[300000][2];struct edge&#123; ll to,next,w;&#125;e[600000];void make(ll u,ll v,ll w)&#123; e[cnt].next=head[u]; e[cnt].to=v; e[cnt].w=w; head[u]=cnt++;&#125;void dfs1(ll x,ll fa)&#123; lian[x][0]=lian[x][1]=-1e18; for(int i=head[x];i;i=e[i].next)&#123; if(e[i].to==fa)continue; dfs1(e[i].to,x); f[x][0]+=max(f[e[i].to][0],f[e[i].to][1]+e[i].w); if(f[e[i].to][0]+e[i].w-max(f[e[i].to][0],f[e[i].to][1]+e[i].w)&gt;lian[x][0])&#123; lian[x][1]=lian[x][0]; lian[x][0]=f[e[i].to][0]+e[i].w-max(f[e[i].to][0],f[e[i].to][1]+e[i].w); son[x][1]=son[x][0]; son[x][0]=e[i].to; &#125; else if(f[e[i].to][0]+e[i].w-max(f[e[i].to][0],f[e[i].to][1]+e[i].w)&gt;lian[x][1])&#123; lian[x][1]=f[e[i].to][0]+e[i].w-max(f[e[i].to][0],f[e[i].to][1]+e[i].w); son[x][1]=e[i].to; &#125; &#125; f[x][1]=f[x][0]+lian[x][0];&#125;void dfs2(ll x,ll fa)&#123; ans=max(ans,f[x][0]); for(int i=head[x];i;i=e[i].next)&#123; if(e[i].to==fa)continue; ll tmpx[2],tmpt[2],tmps[2],tmpl[2]; tmpx[0]=f[x][0],tmpx[1]=f[x][1]; tmpt[0]=f[e[i].to][0],tmpt[1]=f[e[i].to][1]; tmps[0]=son[e[i].to][0],tmps[1]=son[e[i].to][1]; tmpl[0]=lian[e[i].to][0],tmpl[1]=lian[e[i].to][1]; if(e[i].to==son[x][0])&#123; f[x][0]-=max(f[e[i].to][0],f[e[i].to][1]+e[i].w); f[x][1]=f[x][1]-lian[x][0]+lian[x][1]-max(f[e[i].to][0],f[e[i].to][1]+e[i].w); &#125; else&#123; f[x][0]-=max(f[e[i].to][0],f[e[i].to][1]+e[i].w); f[x][1]=f[x][1]-max(f[e[i].to][0],f[e[i].to][1]+e[i].w); &#125; f[e[i].to][0]+=max(f[x][0],f[x][1]+e[i].w); if(f[x][0]+e[i].w-max(f[x][0],f[x][1]+e[i].w)&gt;lian[e[i].to][0])&#123; lian[e[i].to][1]=lian[e[i].to][0]; lian[e[i].to][0]=f[x][0]+e[i].w-max(f[x][0],f[x][1]+e[i].w); son[e[i].to][1]=son[e[i].to][0]; son[e[i].to][0]=x; &#125; else if(f[x][0]+e[i].w-max(f[x][0],f[x][1]+e[i].w)&gt;lian[e[i].to][1])&#123; lian[e[i].to][1]=f[x][0]+e[i].w-max(f[x][0],f[x][1]+e[i].w); son[e[i].to][1]=x; &#125; f[e[i].to][1]=f[e[i].to][0]+lian[e[i].to][0]; dfs2(e[i].to,x); f[x][0]=tmpx[0],f[x][1]=tmpx[1]; f[e[i].to][0]=tmpt[0],f[e[i].to][1]=tmpt[1]; son[e[i].to][0]=tmps[0],son[e[i].to][1]=tmps[1]; lian[e[i].to][0]=tmpl[0],lian[e[i].to][1]=tmpl[1]; &#125;&#125;int main()&#123; scanf(&quot;%lld&quot;,&amp;n); for(int i=1;i&lt;n;i++)&#123; ll u,v,w; scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w); make(u,v,w); make(v,u,w); &#125; dfs1(1,0); dfs2(1,0); printf(&quot;%lld&quot;,ans); return 0;&#125;","title":"小技巧（2）","updated":"2025-09-05T13:37:49.450Z"},{"categories":[],"path":"2023/07/16/生活杂记/diary/5-20/","tags":[],"text":"好久没写过日记了e似乎是不错的一天？又一个自己一个人过的520数学限训错爽了然而却没有因为不会而错的题","title":"5-20","updated":"2025-09-05T13:27:46.055Z"},{"categories":[],"path":"2023/04/30/DP/树上组合计数/","tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"}],"text":"典型例题题目大意：\n有 $n$ 个人，编号为 $1$ 至 $n(n\\le10^5)$ 。除了编号为 $1$ 的人，每个人都有自己的父亲。求出有多少种排队的方式，使得每个人的父亲都排在他的前面。方案数对 $10^9+7$ 取模。\n这类题目其实类似于dp的思想，就是统计方案数我们可以考虑是否可以去除他的一些后效性，然后将子树的数据汇聚到父节点来统计，使得复杂度为dfs枚举点的 $\\Theta(n)$ 乘上计算的 $\\Theta(1)$ 或者 $\\Theta(\\log_2n)$ 。\n那对于这道题来说，我们可以发现子树之间是没有影响的，也就是说，只要保持好每一个子树内部的顺序，子树之间怎么穿插都可以。\n不同子树内部顺序的组合比较好算，就是把他们每个自己的方案数乘起来就行，唯一的难点在于怎么处理穿插可以产生的不同方案数。\n组合数插板法似乎并不适用，这里有一个比较易于理解的办法，随便放的情况除掉乱了子树内部顺序的情况就是合格的情况，即总的排列（也就是总点数-1的阶乘）除以每棵子树大小的阶乘（也就是去掉所有乱的情况）。\n那我们就可以得到方案数的计算方法：\n$$f(x)&#x3D;\\cfrac{(\\prod_{y\\in son_x}{f(y)})*(size_x-1)!}{\\prod_{y\\in son_x}size_y!}$$\n这样一来，正常的dfs统计即可，时间复杂度就是枚举树乘上快速幂求逆元的 $\\Theta(n\\log_2n)$\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n, fa[1000050], head[1000050], cnt = 1, sz[1000050], ans[1000050], mod = 1e9 + 7, jc[1000050];struct edge &#123; int to, next;&#125; e[3000000];void make(int u, int v) &#123; e[cnt].next = head[u]; e[cnt].to = v; head[u] = cnt++;&#125;ll ksm(ll c, ll x) &#123; if (c == 0) return 1; if (c == 1) return x; if (c % 2) return ksm(c / 2, x * x % mod) * x % mod; return ksm(c / 2, x * x % mod);&#125;void dfs(ll x) &#123; ans[x] = 1; for (int i = head[x]; i; i = e[i].next) &#123; if (e[i].to == fa[x]) continue; dfs(e[i].to); ans[x] = ((ans[x] * ans[e[i].to]) % mod * ksm(mod - 2, jc[sz[e[i].to]])) % mod; sz[x] += sz[e[i].to]; &#125; ans[x] = (ans[x] * jc[sz[x]]) % mod; sz[x]++;&#125;int main() &#123; scanf(&quot;%lld&quot;, &amp;n); ll u, v; jc[0] = jc[1] = 1; for (int i = 2; i &lt;= 1000010; i++) &#123; jc[i] = jc[i - 1] * i % mod; &#125; for (int i = 1; i &lt; n; i++) &#123; scanf(&quot;%lld%lld&quot;, &amp;u, &amp;v); fa[u] = v; make(v, u); &#125; dfs(1); printf(&quot;%lld&quot;, ans[1]); return 0;&#125; 变式一要是需要求任意一点为根的答案而数据范围不变呢？\n对于这类“换根”题目我们一般正常就会联想到树上面相邻节点信息的小复杂度转移（譬如$\\Theta(1)$或$\\Theta(\\log_2n)$）\n这道题也不例外——\n朴素一点的做法：和之前一样求完一个钦定的根的答案以后，我们用这个钦定的根的答案向其他点去推，在换根的过程中发生关系变换的其实只有……\n似乎有点不对劲对吧，一开始转换还行，但到后面就会变得逐渐复杂，难以思考，这里提供一个简单一点的思路——\n由于叶子节点的方案数都是1，再将式子里的儿子的信息换成儿子的式子，最终我们得到的总的计算式是这样的：\n$$f(x)&#x3D;\\cfrac{n!}{\\prod_{i\\neq root}size_i}$$\n那么这道题的解决思路也就明了了，转移无非就是乘上两个数再除去两个数（抵消后就只剩乘一个除一个了）。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long long ll n,head[1000000],cnt=1,sz[1000000],ans[1000000],ct[1000000],jc[1000000],mod=1e9+7;struct edge&#123;\tll to,next;&#125;e[1000000];void make(ll u,ll v)&#123;\te[cnt].to=v;\te[cnt].next=head[u];\thead[u]=cnt++;&#125;ll ksm(ll c,ll x)&#123;\tif(c==0)return 1;\tif(c%2)return ksm(c/2,x*x%mod)*x%mod;\treturn ksm(c/2,x*x%mod);&#125;void dfs1(ll x,ll fa)&#123;\tct[x]=1;\tfor(int i=head[x];i;i=e[i].next)&#123; if(e[i].to==fa)continue; dfs1(e[i].to,x); sz[x]+=sz[e[i].to]; ct[x]=((ct[x]*ct[e[i].to])%mod*ksm(mod-2,jc[sz[e[i].to]]))%mod;\t&#125;\tct[x]=(ct[x]*jc[sz[x]])%mod;\tsz[x]++;&#125;void dfs2(ll x,ll fa)&#123;\tif(x!=1)&#123; ans[x]=ans[fa]*ksm(mod-2,n-sz[x])%mod*sz[x]%mod;\t&#125;\tfor(int i=head[x];i;i=e[i].next)&#123; if(e[i].to==fa)continue; dfs2(e[i].to,x);\t&#125;&#125;int main()&#123;\tscanf(&quot;%lld&quot;,&amp;n);\tll u,v;\tjc[0]=jc[1]=1;\tfor(int i=2;i&lt;=1000000;i++)jc[i]=jc[i-1]*i%mod;\tfor(int i=1;i&lt;n;i++)&#123; scanf(&quot;%lld%lld&quot;,&amp;u,&amp;v); make(u,v); make(v,u);\t&#125;\tdfs1(1,0);\tans[1]=ct[1];\tdfs2(1,0);\tfor(int i=1;i&lt;=n;i++)&#123; printf(&quot;%lld\\n&quot;,ans[i]);\t&#125;\treturn 0;&#125;","title":"树上组合计数","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/04/02/图论/dsuontree/","tags":[],"text":"引入题目地址\n题目大意：给一棵 $N$ 个点、有边权的树，求最小的不小于k的一条树上路径的长度。\n我的第一想法肯定是把每个节点的的信息不断像上传，同时还在这个节点的位置处理子树中到它和跨过它的路径的信息，但这样的复杂度是最坏 $\\Theta(N^2)$ 的，只需要用一条链就可以轻松卡掉它。。。看一眼数据范围，典型的要带一两个 $log$ 那怎么办，就引出我们的主题了：\n树上启发式合并（dsu on tree）这玩意乍一看很玄学，因为启发式就显得它很难懂，也很高大上，但事实上你只需要感性理解一下，放轻松~\n回忆一下重链剖分中，对于一棵树的一个节点，从根节点到它的轻边数是不超过 $log N$ 的[^1]，\n那我们便可以考虑对所有轻边连接的子树中的节点暴力进行遍历；而对于重边连接的子树的信息我们则选择保留而不是传到父亲后重新遍历。\n这样一个节点总体上被遍历的次数便不会超过根节点到它的轻边数 $logN+1$ ，加 $1$ 是因为到它自己更新信息时要遍历它自己\n总时间复杂度便为 $\\Theta(NlogN)$\n对于本题说完了知识点总得回归到题目吧，对于这道题我们可以先 $\\Theta(N)$ 求出每个节点到根节点的路径长度（即深度）、重儿子、子树大小、 dfs 序，\n然后我们用 set 维护那个要传着用的值，也就是重儿子那一棵子树上所有节点到根路径的长度，根据每次新暴力加进来的节点到当前节点的长度，用 lower_bound ( ) 查询最有希望成为和这个长度加起来更新答案的值，并更新答案。\n去除轻子树的影响时只需要在遍历完这棵子树后清空 set 即可\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longll n,k,head[500005],cnt=1,a,b,c,d[500005],dfn[500005],r[500005],tot,hev[500005],size[500005],ans,dfnto[500005];struct edge&#123;\tll to,next,w;&#125;e[1000005];set&lt;ll&gt; s;void make(ll u,ll v,ll w)&#123;\te[cnt].to=v;\te[cnt].next=head[u];\te[cnt].w=w;\thead[u]=cnt++;&#125;void dfs1(ll x,ll fa,ll depth)&#123;\td[x]=depth;\tdfn[x]=++tot;\tdfnto[tot]=x;\tll biggest=0;\tfor(int i=head[x];i;i=e[i].next)&#123; if(e[i].to==fa)continue; dfs1(e[i].to,x,depth+e[i].w); size[x]+=size[e[i].to]+1; if(size[e[i].to]+1&gt;biggest) biggest=size[e[i].to]+1,hev[x]=e[i].to;\t&#125;\tr[x]=tot;&#125;void in(ll x,ll cut)&#123;\tauto it=s.lower_bound(k-x+2*cut);\tif(it!=s.end())&#123; if(x+*it-2*cut&gt;=k) ans=min(ans,x+*it-2*cut);\t&#125;\telse if(x-cut&gt;=k)ans=min(ans,x-cut);\ts.insert(x);&#125;void dfs2(ll x,ll fa,ll add)&#123;\tfor(int i=head[x];i;i=e[i].next)&#123; if(e[i].to!=hev[x]&amp;&amp;e[i].to!=fa)dfs2(e[i].to,x,0);\t&#125;\tif(hev[x])dfs2(hev[x],x,1);\tfor(int i=head[x];i;i=e[i].next)&#123; if(e[i].to!=fa&amp;&amp;e[i].to!=hev[x])&#123; for(int j=dfn[e[i].to];j&lt;=r[e[i].to];j++)&#123; in(d[dfnto[j]],d[x]); &#125; &#125;\t&#125;\tin(d[x],d[x]);\tif(add==0)&#123; s.clear();\t&#125;&#125;int main()&#123;\tfreopen(&quot;tree.in&quot;,&quot;r&quot;,stdin); freopen(&quot;tree.out&quot;,&quot;w&quot;,stdout); cin&gt;&gt;n&gt;&gt;k;\tfor(int i=1;i&lt;n;i++)&#123; cin&gt;&gt;a&gt;&gt;b&gt;&gt;c; make(b,a,c); make(a,b,c);\t&#125;\tans=1e18;\tdfs1(1,0,0);\tdfs2(1,0,0);\tif(ans==1e18)\tcout&lt;&lt;-1;\telse\tcout&lt;&lt;ans;\treturn 0;&#125; [^1]: 证明：设 $x$ 为根节点到该节点的轻边数， $y$ 为该节点的子树大小，那么因为轻边连接的子树最大不大于它的父节点的子树大小的一半，所以有 $y&lt;&#x3D;\\cfrac{N}{2^x}$ ，所以$x&lt;logN$","title":"树上启发式合并（dsu on tree）","updated":"2025-09-05T13:37:49.444Z"},{"categories":[],"path":"2023/04/02/DP/四边形不等式优化/","tags":[],"text":"四边形不等式与蒙日矩阵首先讲一下这玩意的用处，个人认为这是在理解四边形不等式优化中最能引入的点：限制状态的枚举，也就是所谓的决策单调性（看起来像废话因为所有优化都是在限制枚举的范围）\n对不同类型的$dp$，如果它的状态转移满足四边形不等式，其实我们都可以以某种方式得到决策单调性，所以尽管下面讲的证明比较具有局限性，但是他的应用往往是需要一些想像力的。\n设 $w_{x,y}$ 为定义在整数集合上的二元函数。若 $\\forall l\\le l’\\le r’\\le r : w_{l,r’}+w_{l’,r}\\le w_{l,r}+w_{l’,r’}$ ，可记作交叉小于包含，则称函数 $w_{x,y}$ 满足四边形不等式。\n事实上，对于一个二元函数是否满足四边形不等式可以通过更简便的方法证明：\n设 $w_{x,y}$ 为定义在整数集合上的二元函数。若 $\\forall l\\lt r : w_{l,r+1}+w_{l+1,r}\\le w_{l,r}+w_{l+1,r+1}$ ，则称函数 $w_{x,y}$ 满足四边形不等式。\n正确性的证明如下：\n$$\\forall a\\lt c:w_{a,c}+w_{a+1,c+1}\\le w_{a+1,c}+w_{a,c+1}$$\n$$\\forall a+1\\lt c:w_{a+1,c}+w_{a+2,c+1}\\le w_{a+1,c+1}+w_{a+2,c}$$\n两式相加，可得\n$$w_{a,c}+w_{a+2,c+1}\\le w_{a+2,c}+w_{a,c+1}$$\n以类似第二个式子的方法，可以以不断加的方法把a这一边推广至：\n$$\\forall a\\le b\\le c:w_{a,c}+w_{b,c+1}\\le w_{b,c}+w_{a,c+1}$$\n用同样的方法也可以扩展c这一边至：\n$$\\forall a\\le b\\le c\\le d:w_{a,c}+w_{b,d}\\le w_{b,c}+w_{a,d}$$\n证毕。\n（下面的证明会用到一些式子的合并以及非等量但是满足单调性的代换，比上面的更复杂一点，请注意其运用）\n1D&#x2F;1D dp的优化笔者其实并不知道什么是1D&#x2F;1D dp，可能是一维dp吧\n对于某些形如：\n$$f_{i}&#x3D;\\min_{j&#x3D;1}^{i}(f_j+w_{j,i})$$\n的$dp$，设对于一个位置 $i$，他的最优决策选取的位置为 $k_{i}$，如果 $w_{i,j}$ 满足四边形不等式，则有\n$$\\forall i\\le j : k_i\\le k_j$$\n证明:假设 $\\forall i\\le j :k_j\\lt k_i$ ,那么 $k_j\\lt k_i\\lt i\\le j$ ,根据四边形不等式有：\n$$w_{k_j,i}+w_{k_i,j}\\le w_{k_j,j}+w_{k_i,i}$$\n又因为 $k_j$ 是 $j$ 的最优决策点，所以有：\n$$f_{k_j}+w_{k_j,j}\\le f_{k_i}+w_{k_i,j}$$\n两式相加，可得：\n$$f_{k_j}+w_{k_j,i}\\le f_{k_i}+w_{k_i,i}$$\n这也就与 $k_i$ 为 $i$ 的最优决策点相冲突，因此 $k_i$ 必然小于 $k_j$ 。\n证毕。\n那么既然知道了最优决策点的位置的单调性，我们便可以在每一次遍历到新的下标 $i$ 时，利用二分找到以自己为最优决策点的最靠前的位置并更新后面的全部，这样时间复杂度就从$\\Theta(n^2)$变为了$\\Theta(n\\log n)$\n2D&#x2F;1D dp的优化然而笔者也不知道什么是2D&#x2F;1D dp，或许可以理解为二维的dp吧\n对于经典的区间$dp$，我们往往需要枚举区间左右端点和中间的断点，那它的复杂度自然就是显而易见的$\\Theta(n^3)$\n然而有些时候，你会发现这个三次方是过不了的，可能需要消掉一个$n$，在这种情况下，我们可以考虑去证明他的决策单调性（如果你对证明有疑问，大可先去看看结论起的用处再回来看证明）OIwiki\n再引入一个概念：\n区间包含单调性：若对于任意的 $l\\le l’\\le r’\\le r$ ，满足 $w_{l’,r’}\\le w_{l,r}$ 则称 $w_{l,r}$ 满足区间包含单调性。\n总结其实我们真正在使用四边形不等式优化的时候，首先是要想到他最开始的状态转移方程，由于很有可能有多种非正解的设计方式，所以我们其实应该不止揪着一种去想他的优化（头够铁也未必不行），多设计几种，看看那种类似我们提到过的模型，再试一试证明它的取值函数满足四边形不等式（哪怕是打个表看看是否满足决策单调性），如果可以，而时间复杂度又符合，那肯定就做完了$qwq$","title":"四边形不等式优化","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/04/02/数学/中国剩余定理/","tags":[],"text":"解一组同余方程\n$$\\left{\\begin{array}{c}x\\equiv a_1(\\mod m_1)\\x\\equiv a_2(\\mod m_2)\\\\cdots\\x\\equiv a_k(\\mod m_k)\\\\end{array}\\right.$$\nType1设 $m_1,m_2,m_3\\quad\\cdots\\quad m_k$ 两两互质，\n那我们考虑对他们一一解决\n前置小提示：由于所有的模数两两互质，所以最终式的模数即可为$\\prod_{i&#x3D;1}^{k}{m_i}$\n对于任意一个式子 $j$ 我们想让他在其他式子不受影响的同时被满足，那便需要累计的答案加上的数是其他式子模数的倍数，同时还要使得此式变得成立，\n那这个加数必然含有一个因子为 $\\cfrac{\\prod_{i&#x3D;1}^{k}{m_i}} {m_j}$ ,用 $exgcd$ 求其在模 $m_j$ 下的逆元，再把他们和 $a_j$ 相乘，便可得到这个加数。\n最小正整数解即为累计的答案（若要其他解可以不断加 $\\prod_{i&#x3D;1}^{k}{m_i}$ 来得到）\n1234567891011121314151617#define ll long long ll a[K],m[K],k,ans,M=1,x,y;for(int i=1;i&lt;=k;i++)&#123; M*=m[i];&#125;for(int i=1;i&lt;=k;i++)&#123; ans=(ans+(M/m[i]*a[i]/exgcd(M/m[i],m[i])*x)%M)%M;&#125; 时间复杂度 $\\Theta(n\\log n)$\nType2我们现在来看一下更平凡的情况：\n模数不一定两两互质，在这种情况下方程组不一定有解\n我们可以把式子两两合并，\n设最终的解为$x$,我们可以把式子转化为\n$$x&#x3D;a_i+m_ix_i$$ 的形式\n每次取出其中的两个合并，便等价于求解\n$$m_ix_i+m_jx_j&#x3D;a_j-a_i$$\n此时用 $exgcd$ 求逆元的同时可以判断有无解\n把得到的解代回原式 $(x&#x3D;a_i+m_ix_i)$ 得到的 $x$ 即为新方程的余数，下面记作 $x’$\n新方程的模数为 $lcm(m_i,m_j)$\n得到的式子即为\n$$x\\equiv x’\\pmod {lcm(m_i,m_j)}$$\n12345678910111213141516171819202122232425#define ll long long ll a[K],m[K],k,ans,x,y,nowm,nowa;nowm=m[1],nowa=a[1];for(int i=2;i&lt;=k;i++)&#123; if((a[i]-nowa)%exgcd(nowm,m[i],x,y))&#123; cout&lt;&lt;-1&lt;&lt;endl; return 0; &#125; nowa+=nowm*x; nowm=lcm(nowm,m[i]);&#125;cout&lt;&lt;nowa&lt;&lt;endl; 时间复杂度 $\\Theta(n\\log n)$\n番外：南外讲座的大佬说这个貌似模意义下的拉格朗日插值 $QwQ$","title":"中国剩余定理","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/04/02/数学/二项式反演/","tags":[],"text":"$$g(n) &#x3D;\\sum_{i&#x3D;1}^n{n\\choose i}f(i) \\Longleftrightarrow f(n)&#x3D;\\sum_{i&#x3D;1}^n (-1)^{n-i}{n \\choose i}g(i)$$\n先把左边代入右边消掉\n$$f(n)&#x3D;\\sum_{i&#x3D;1}^{n}(-1)^{n-i}{n\\choose i}*\\sum_{j&#x3D;1}^{i}{i\\choose j}f(j)$$\n换一下式子的顺序\n$$f(n)&#x3D;\\sum_{j&#x3D;1}^{n}f(j)*\\sum_{i&#x3D;j}^{n}(-1)^{n-i}{n\\choose i}{i\\choose j}$$\n拆开组合数并化简\n$$\\sum_{i&#x3D;j}^{n}(-1)^{n-i}\\cfrac{n!}{i!(n-i)!}\\cfrac{i!}{j!(i-j)!}$$\n$$&#x3D;\\sum_{i&#x3D;j}^{n}(-1)^{n-i}\\cfrac{n!}{j!(n-i)!(i-j)!}$$\n$$&#x3D;\\cfrac{n!}{j!}\\sum_{i&#x3D;j}^{n}\\cfrac{(-1)^{n-i}}{(n-i)!(i-j)!}$$\n内乘外除$(n-j)!$\n$$&#x3D;\\cfrac{n!}{j!(n-j)!}\\sum_{i&#x3D;j}^{n}(-1)^{n-i}\\cfrac{(n-j)!}{(n-i)!(i-j)!}$$\n把分数转回组合数\n$$&#x3D;{n\\choose j}\\sum_{i&#x3D;j}^{n}(-1)^{n-i}{n-j\\choose n-i}$$\n因为\n$$f(n)&#x3D;\\sum_{j&#x3D;1}^{n}[j&#x3D;&#x3D;n]*f(j)$$\n所以就相当于证明：\n$${n\\choose j}\\sum_{i&#x3D;j}^{n}(-1)^{n-i}{n-j\\choose n-i}&#x3D;\\begin{cases}\n0\\quad(j&lt;n)\\ 1\\quad(j&#x3D;n) \\\n\\end{cases}$$\n证明： $j&#x3D;n$ 时：\n原式等于： $${n\\choose n}(-1)^0{0\\choose0}&#x3D;1$$ $j\\not &#x3D; n$ 时：\n有$\\sum_{i&#x3D;j}^{n}(-1)^{n-i}{n-j\\choose n-i}&#x3D;0$\n证明：\n当 $n-j$ 为奇数时，\n取值正好有 $n-j+1$ 个，且正好两两相反可以抵消，也就是 ${n-j\\choose n-i}$ 和 ${n-j\\choose n-j-(n-i)}$，他们值相等，但系数相反；\n当 $n-j$ 为偶数时，\n根据二项式定理： $$\\sum_{i&#x3D;0}^n C(n,i) (-1)^{n-i}$$\n$$&#x3D; \\sum_{i&#x3D;0}^n C(n,i) (-1)^{n-i}1^i$$\n$$&#x3D;(1-1)^n$$\n$$&#x3D;0^n$$\n$$&#x3D;0$$\n反演得证","title":"二项式反演","updated":"2025-09-05T13:37:49.442Z"},{"categories":[],"path":"2023/04/02/数学/二项式定理/","tags":[],"text":"$$(x+y)^n&#x3D;\\sum_{i&#x3D;0}^{n}{n\\choose i}x^{n-i}y^{i}&#x3D;\\sum_{i&#x3D;0}^{n}{n\\choose i}x^{i}y^{n-i}$$\n证明：数学归纳法：\n下界：当$\\displaystyle n&#x3D;1$时，$(x+y)^1&#x3D;\\sum_{i&#x3D;0}^{1}{1\\choose i}x^{1-i}y^{i}&#x3D;{1\\choose 0}x^{1}y^{0}+{1\\choose 1}x^{0}y^{1}&#x3D;x+y$，此时定理显然成立\n那么当 $n$ 成立时，对于 $n+1$ 有：\n$$(x+y)^{n+1}$$\n拆出一个$(x+y)$\n$$&#x3D;x(x+y)^n+y(x+y)^n$$\n按定理代入\n$$&#x3D;x\\sum_{i&#x3D;0}^{n}{n\\choose i}x^{n-i}y^{i}+y\\sum_{j&#x3D;0}^{n}{n\\choose j}x^{n-j}y^{j}$$\n把 $x$ 和 $y$ 乘进去\n$$&#x3D;\\sum_{i&#x3D;0}^{n}{n\\choose i}x^{n-i+1}y^{i}+\\sum_{j&#x3D;0}^{n}{n\\choose j}x^{n-j}y^{j+1}$$\n取出首和尾\n$$&#x3D;x^{n+1}+\\sum_{i&#x3D;1}^{n}{n\\choose i}x^{n-i+1}y^{i}+\\sum_{j&#x3D;0}^{n-1}{n\\choose j}x^{n-j}y^{j+1}+y^{n+1}$$\n把 $j$ 换成 $i-1$\n$$&#x3D;x^{n+1}+\\sum_{i&#x3D;1}^{n}{n\\choose i}x^{n-i+1}y^{i}+\\sum_{i&#x3D;1}^{n}{n\\choose i-1}x^{n-i+1}y^{i}+y^{n+1}$$\n合并两个sum\n$$&#x3D;x^{n+1}+\\sum_{i&#x3D;1}^{n}\\bigg({n\\choose i}+{n\\choose i-1}\\bigg)x^{n-i+1}y^{i}+y^{n+1}$$\n根据组合数的性质合并两个组合数的和[^1]\n$$&#x3D;x^{n+1}+\\sum_{i&#x3D;1}^{n}{n+1\\choose i}x^{n-i+1}y^{i}+y^{n+1}$$\n因为 $1&#x3D;{n+1\\choose 0}$ 且 $1&#x3D;{n+1\\choose n+1}$ ，所以可以把 $x^{n+1}$ 和 $y^{n+1}$ 合并入sum\n$$&#x3D;\\sum_{i&#x3D;0}^{n+1}{n+1\\choose i}x^{(n+1)-i}y^{i}$$\n显然仍符合二项式定理\n证毕\n其实还有更简单的感性理解一下：\n考虑组合数定义，每种二项式得到的次数可以看作你在 $n$ 个数对中选出其中一项的指数个的不同的方案数，也就是${n\\choose 指数}$，加起来就成了整个式子。\n[^1]: ${n\\choose m}&#x3D;{n-1\\choose m}+{n-1\\choose m-1}$，$n$个数里选$k$个数的方案数即：选当前这个数和不选这个数的方案数的和","title":"二项式定理","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/04/02/数学/欧拉函数与欧拉定理/","tags":[],"text":"积性函数定义：若 $a,b$ 互质时，有 $f(ab)&#x3D;f(a)*f(b)$ ,那么称函数 $f$ 为积性函数。\n$ps$：$cbj$大佬说所有积性函数都可以用线性筛求值 $qwq$\n欧拉函数$\\varphi(n)$ 表示比 $n$ 小的与 $n$ 互质的正整数的个数\n对 $n$ 做质因数分解,得到 $n&#x3D;p_1^{c_1}p_2^{c_2}\\cdots p_m^{c_m}$ 则：\n$$\\varphi(n)&#x3D;n*(1-{1\\over p_1})(1-{1\\over p_2})\\cdots *(1-{1\\over p_m})$$\n证明：\n若 $n$ 含有两个不同的质因子 $p,q$ ,\n那么在 $1$ ~ $n$ 中 $p$ 的倍数有 $\\cfrac {n}{p}$ 个，$q$ 的倍数有 $\\cfrac {n}{q}$ 个，\n如果我们把这 $\\cfrac {n}{p}+\\cfrac {n}{q}$ 个数减掉，\n那么 $p,q$ 的共同因子就会被排除两遍，需要加回来一次。\n因此 $1$ ~ $n$ 中不与 $n$ 含有共同因子 $p,q$ 的数的个数为：\n$$n-\\cfrac {n}{p}-\\cfrac {n}{q}+\\cfrac {n}{pq}&#x3D;n(1-{1\\over p})(1-{1\\over q})$$\n欧拉函数是积性函数证明：根据我们得到的式子可得对于两个互质的数 $a,b$ 有\n$$\\varphi(a)\\varphi(b)&#x3D;a*\\prod_{质数p\\mid a}(1-p)b\\prod_{质数p\\mid b}(1-p)&#x3D;(ab)\\prod_{质数p\\mid (ab)}(1-p)&#x3D;\\varphi(ab)$$\n线性筛求欧拉函数的值 ：需要利用的三条性质： 1 若 $x$ 为质数，那么 $\\varphi(x)&#x3D;x-1$\n2 设 $p$ 为质数，若对于一个数 $x$ 有 $p\\mid x$ 且 $p^2\\mid x$ ,则 $\\varphi(x)&#x3D;\\varphi(x&#x2F;p)*p$\n3 设 $p$ 为质数，若对于一个数 $x$ 有 $p\\mid x$ 但 $p^2\\not\\mid x$ ,则 $\\varphi(x)&#x3D;\\varphi(x&#x2F;p)*\\varphi(p)$ 证明：\n第一条性质是显然的\n第二条性质可以从公式中得到，因为 $x$ 和 $x&#x2F;p$ 含有的质因子种类完全一样，所以 $\\varphi(x)$ 和 $\\varphi(x&#x2F;p)$ 的商由公式可得是 $p$ ，所以 $\\varphi(x)&#x3D;\\varphi(x&#x2F;p)*p$\n第三条性质可以直接由 $\\varphi(n)$ 为积性函数得到\n那么我们就可以利用这三条性质，在线性筛的基础上在 $\\Theta(n)$ 的时间复杂度里求出 $1$~$n$ 的欧拉函数\n12345678910111213141516171819202122232425262728293031#define ll long longll n,phi[N],prime[N],tot,v[N];for(int i=2;i&lt;=n;i++)&#123; if(v[i]==0)&#123; prime[tot++]=i; phi[i]=i-1; v[i]=i; &#125; for(int j=0;j&lt;tot;j++)&#123; if(v[i]&lt;prime[j]||prime[j]*i&gt;n)break; v[i*prime[j]]=prime[j]; if(i%prime[j])phi[i*prime[j]]=phi[i]*phi[prime[j]]; else phi[i*prime[j]]=phi[i]*prime[j]; &#125;&#125; 欧拉定理$$a^{\\varphi(n)}\\equiv1\\pmod n\\quad\\quad (a\\bot n)$$\n证明：\n$$a^{\\varphi(n)}x_1x_2x_3\\cdots x_{\\varphi(n)}\\pmod n \\tag{1}$$\n$$\\equiv (ax_1)(ax_2)\\cdots(ax_{\\varphi(n)})\\pmod n \\tag{2}$$\n因为 $a\\bot n$ , 所以 $x_i\\bot n$ ,所以 $ax_i\\bot n$ ，所以 $ax_i \\mod m$ 属于 $n$ 的简化剩余系，\n因为 {$x_1,x_2,x_3\\cdots x_{\\varphi(n)}$} 正好构成了 $n$ 的简化剩余系，又有对于任意不相等的 $x_i,x_j$ 存在若 $a\\bot n$ 那么 $ax_i\\not\\equiv ax_j\\pmod n$\n所以,对构成 $n$ 的简化剩余系的元素分别乘上 $a$ ,得到的数恰好又构成 $n$ 的简化剩余系,\n即上面的式子等价于：\n$$x_1x_2x_3\\cdots x_{\\varphi(n)}\\pmod n \\tag{3}$$\n对(1)、(3)式两边同除 $x_1x_2x_3\\cdots x_{\\varphi(n)}$ 可得：\n$$a^{\\varphi(n)}\\equiv1\\pmod n$$\n证毕。\n可以发现其实费马小定理就是欧拉定理的特例，因为当p为质数时，$\\varphi(p)&#x3D;p-1$\n扩展：\n$$a^{b}\\equiv a^{b\\mod\\varphi(n)}\\pmod n\\quad\\quad (a\\bot n)$$\n证明：设 $b&#x3D;q*\\varphi(n)+r$ ,其中 $0\\leq r&lt;\\varphi(n)$ ,即 $r&#x3D;b \\mod\\varphi(n)$ ,于是：\n$$a^b\\equiv a^{q*\\varphi(n)+r}\\equiv1^q*a^r\\equiv a^r\\equiv a^{b \\mod\\varphi(n)}\\pmod n$$\n证毕\n这个欧拉定理的小扩展可以帮我们有效降幂，但是他显然还不够一般，为了可以更方便的降幂，我们有：\n扩展欧拉定理$$a^b \\equiv a^{(b\\mod\\varphi(c))+\\varphi(c)}\\pmod c$$\n证明：\n我们可以考虑对 $a$ 做质因数分解，\n对于 $a$ 的质因数中与 $c$ 互质的 $p$ 因为欧拉定理显然符合上式，\n对于 $p\\mid c$ ，我们可以先把 $c$ 拆成 $sp^r$ ，其中 $s$ 与 $p$ 互质，因为$p^{\\varphi(s)}\\equiv 1\\pmod s$，因为欧拉函数为积性函数，所以 $\\varphi(s)\\varphi(p^r)&#x3D;\\varphi(c)$ ，那么显然有\n$$p^{\\varphi(c)}\\equiv1\\pmod s$$\n从而\n$$p^{b}\\equiv p^{b\\mod\\varphi(c)}\\pmod s$$\n两边同乘 $p^r$，因为 $c&#x3D;s*p^r$，所以\n$$p^{b+r}\\equiv p^{(b\\mod\\varphi(c))+r}\\pmod c$$\n因为 $c&#x3D;s*p^r$，所以 $\\varphi(c)\\ge r$，所以可以对两边同乘 $p^{\\varphi(c)-r}$\n$$p^{b}\\equiv p^{(b\\mod\\varphi(c))+\\varphi(c)}\\pmod c$$\n证毕","title":"欧拉函数与欧拉定理","updated":"2025-09-05T13:37:49.442Z"},{"categories":[],"path":"2023/04/02/数学/扩展欧几里得算法/","tags":[],"text":"解二元一次不定方程$$ax+by&#x3D;c$$\n有解的条件： $ \\gcd(a,b)\\mid c$(若 $\\gcd(a,b)$ 与 $c$ 互质或大于则无法配出，因为 $a$ 与 $b$ 能配出的数为 $\\gcd(a,b)$ 的倍数)\n对原式两边同除$\\gcd(a,b)$，得到 $a’x+b’y&#x3D;c’$ 此时 $a’\\bot b’$ ，如此可用 $exgcd$ 来求 $a’x+b’y&#x3D;1$ 的解，进而对得到的答案分别乘以 $c’$ 即可。\n求解可在求解 $\\gcd$ 的过程中实现，先将上式变到未知 $\\gcd(a,b)$ 前的 $ax+by&#x3D;\\gcd(a,b)$代入辗转相除过程：\n$$ax+by$$\n$$&#x3D;\\gcd(a,b)$$\n$$&#x3D;\\gcd(b,a\\mod \\quad b)$$\n$$&#x3D;bx’+(a\\mod \\quad b)y’$$\n$$\\ldots$$\n$$&#x3D;1$$\n$$(a\\bot b)$$\n$$\\left{\\begin{array}{c}x_n&#x3D;1\\y_n&#x3D;0\\end{array}\\right.$$\n看两层间关系：\n$$ax+by$$\n$$&#x3D;bx’+(a\\mod \\quad b)y’$$\n$$&#x3D;ay’ +b(x’-\\lfloor {a \\over b} \\rfloor y’)$$\n由此可以看出：\n$$\\left{ \\begin{array}{c}x&#x3D;y’\\y&#x3D;x’- \\lfloor {a \\over b} \\rfloor y’\\\\end{array}\\right.$$\n那么我们就可以用最后那一组确定的特解不断向前代直到得到 $ax+by&#x3D;\\gcd(a,b)$ 的解最后附上一份 $exgcd$ 的代码\n123456789#define ll long longll exgcd(ll a,ll b)&#123;\tif(b==0)return a;\tll res=gcd(b,a%b);\tll x1=x,y1=y;\tx=y1;\ty=x1-a/b*y1;\treturn res;&#125; 时间复杂度$\\Theta(\\log n)$\n解同余方程$$ax\\equiv b\\pmod m$$\n考虑先把他转换成普通的方程：\n$$ax&#x3D;b-my$$\n移项得\n$$ax+my&#x3D;b$$\n之后便可按解二元一次不定方程的步骤来求解","title":"扩展欧几里得算法","updated":"2025-09-05T13:37:49.442Z"},{"categories":[],"path":"2023/03/29/DP/ddp/","tags":[],"text":"warning，这不是一篇新手向博文，最适人群为学过但忘记此算法，本篇将帮助你的回忆\n一、导入顾名思义，动态动态规划（ddp）就是支持修改操作的dp问题，常见于带修改的树形dp，一般使用线段树套广义矩阵乘法来实现\n二、前置知识线段树、矩阵乘法、树剖什么的肯定要会鸭在处理树形问题前，我们先解决简化版的线性问题——例题：小白逛公园这个题当然大部分人只会关注他的奇妙纯线段树解这是一个最大子段和问题，如果不带修，我们绝大多数情况下是用dp直接解决的，但是，请仔细思考一下，矩阵乘法其实是一类求解过程，它虽然看起来复杂，但却可以做到与很多算法等价，譬如$floyd$求最短路，当然，它也可以用于求解最大子段和问题，我们维护两个值$f_i$，$g_i$，分别表示$i$之前的最大子段和 和 包含且恰好截至$i$的最大子段和，那么我们就可以根据广义矩阵乘法的定义设计出相应的矩阵，即答案矩阵为：\n$$\\begin{bmatrix}f&amp;g&amp;0\\end{bmatrix}$$\n而过程中的矩阵则为：\n$$\\begin{bmatrix}0&amp;-\\infty&amp;-\\infty\\a_i&amp;a_i&amp;-\\infty\\0&amp;0&amp;0\\end{bmatrix}$$\n这道题让我们算出区间的最大子段和，那乍一看我们的做法就没法得到答案了，其实不然根据广义矩阵乘法的结合律，我们可以把计算过程拆分为初始答案矩阵和过程答案矩阵，我们发现，只要每次快速查询出一段区间的过程矩阵积，用初始的答案矩阵乘上即可，那带修、支持区间查询，自然就需要线段树来维护，本题就做完了。","title":"浅谈ddp","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/03/29/数学/stl/","tags":[],"text":"定义第二类斯特林数$\\begin{Bmatrix}n\\k\\end{Bmatrix}$表示将 $n$ 个两两不同的元素划分为 $k$ 个互不区分的非空子集的方案数。\n递推式$$\\begin{Bmatrix}n\\k\\end{Bmatrix}&#x3D;\\begin{Bmatrix}n-1\\k-1\\end{Bmatrix}+k*\\begin{Bmatrix}n-1\\k\\end{Bmatrix}$$\n类似于组合数的递推式，我们考虑加入一个新元素后子集个数达到 $k$ 的时候，它的方案数就等于这个元素自己分到一个新子集的方案数，即 $\\begin{Bmatrix}n-1\\k-1\\end{Bmatrix}$ ，加上把它分到之前已有的集合中的方案数，即 $k*\\begin{Bmatrix}n-1\\k\\end{Bmatrix}$ 。\n通项公式$$\\begin{Bmatrix}n\\k\\end{Bmatrix}&#x3D;\\sum_{i&#x3D;0}^{k}\\cfrac{(-1)^{k-i}i^n}{i!(k-i)!}$$\n证明：设 $G_j$ 表示将 $n$ 个两两不同的元素划分为 $j$ 个相互区分的子集**（可以为空）的方案数，$F_j$ 表示将 $n$ 个两两不同的元素划分为 $k$ 个相互区分的非空子集**的方案数，所以有：\n$$G_j&#x3D;i^j$$\n$$G_j&#x3D;\\sum_{i&#x3D;0}^{j}{j\\choose i}F_i$$\n根据二项式反演可得：\n$$F_j&#x3D;\\sum_{i&#x3D;0}^{j}(-1)^{j-i}{j\\choose i}G_i$$\n$$&#x3D;\\sum_{i&#x3D;0}^{j}(-1)^{j-i}{j\\choose i}i^n$$\n$$&#x3D;\\sum_{i&#x3D;0}^{j}\\cfrac{j!(-1)^{j-i}i^n}{i!(j-i)!}$$\n考虑 $F_j$ 因为和斯特林数的区别只有 $F_j$ 区分子集，所以 $F_j$ 正好为斯特林数的 $j!$倍，即\n$$\\begin{Bmatrix}n\\k\\end{Bmatrix}&#x3D;\\cfrac{F_k}{k!}&#x3D;\\sum_{i&#x3D;0}^{k}\\cfrac{(-1)^{k-i}i^n}{i!(k-i)!}$$","title":"第二类斯特林数","updated":"2025-09-05T13:37:49.437Z"},{"categories":[],"path":"2023/03/29/数据结构/stntree/","tags":[],"text":"引入众所周知，最小生成树是用来解决图上最小代价联通的问题的，但是他有一个局限性，那就是他仅适用于必须将所有点全部联通的情况。\n有一类问题，需要求图上联通所有关键点的最小代价，在这种情况下，之前的最小生成树的策略显然不适用，因为不必连接所有点，但又可能会存在一些中转点，看起来非常的凌乱，这个时候，就需要用到斯坦纳树\n模板题目描述\n这是斯坦纳树的经典例题，题面就不过多赘述，解决这一问题，我们考虑$dp$，状压并不好办，因为节点数太多，但是发现关键点数并不多，于是设计出来$dp$数组为$f_{p,s}$，其中$p$表示指定为树根的节点下标，$s$为当前树对关键点的包含状态，数组存的值，即为最小代价，\n可是我们发现，这图显然不是$DAG$，那没有拓扑序怎么$dp$呢，这时候可以用最短路的思想来协助$dp$,如同最短路的更新操作，我们可以使用一个点的$dp$值来更新其他点的$dp$值，同时，还有针对于同根的子树的合并更新\n代码如下\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;using namespace std;#define ll long longtypedef pair&lt;int,int&gt; P;ll n,m,k,key[15],head[105],cnt=1,dp[105][2000];struct edge&#123; ll to,next,w;&#125;e[1005];struct node&#123; ll val,pos; bool operator &lt;(const node &amp;a)const&#123; return val&gt;a.val; &#125;&#125;tmp;void make(ll u,ll v,ll w)&#123; e[cnt].next=head[u]; e[cnt].to=v; e[cnt].w=w; head[u]=cnt++;&#125;priority_queue&lt;node&gt; q;void dij(ll s)&#123;//这是类最短路松弛更新 while(!q.empty())&#123; tmp=q.top(); q.pop(); ll p=tmp.pos; if(tmp.val&lt;dp[p][s])continue; for(int i=head[p];i;i=e[i].next)&#123; if(dp[p][s]+e[i].w&lt;dp[e[i].to][s])&#123; dp[e[i].to][s]=dp[p][s]+e[i].w; tmp.pos=e[i].to; tmp.val=dp[e[i].to][s]; q.push(tmp); &#125; &#125; &#125;&#125;int main()&#123; scanf(&quot;%lld%lld%lld&quot;,&amp;n,&amp;m,&amp;k); ll u,v,w; for(int i=1;i&lt;=m;i++)&#123; scanf(&quot;%lld%lld%lld&quot;,&amp;u,&amp;v,&amp;w); make(u,v,w); make(v,u,w); &#125; for(int i=1;i&lt;=n;i++)&#123; for(int j=0;j&lt;=(1&lt;&lt;k);j++)&#123; dp[i][j]=1e18; &#125; &#125; for(int i=1;i&lt;=k;i++)&#123; scanf(&quot;%lld&quot;,&amp;key[i]); dp[key[i]][1&lt;&lt;(i-1)]=0; &#125; for(int i=1;i&lt;(1&lt;&lt;k);i++)&#123; for(int j=1;j&lt;=n;j++)&#123; for(int o=(i-1)&amp;i;o;o=(o-1)&amp;i)&#123; dp[j][i]=min(dp[j][i],dp[j][o]+dp[j][i^o]);//这是合并更新 &#125; if(dp[j][i]!=1e18)&#123;tmp.pos=j,tmp.val=dp[j][i],q.push(tmp);&#125; &#125; dij(i); &#125; printf(&quot;%lld&quot;,dp[key[1]][(1&lt;&lt;k)-1]); return 0;&#125;","title":"斯坦纳树","updated":"2025-09-05T13:37:49.442Z"},{"categories":[],"path":"/FFT-NTT/","tags":[],"text":"FFT大佬博客基本的东西在这里面都比较全，解释一下一些可能的疑点： 其实单位根还有一条比较好用的性质——$w^x_n*w^y_n&#x3D;w^{x+y}_n$ ,关于这一结论可以先转为复数形式，相乘并用三角函数恒等变换化简得到\n最开始存系数的数组在跑完第一遍FFT以后，存的就相当于那$n$个$x$对应的$y$了\n之所以每一层出来出来的$w^k_n$所属的$n$会不一样，其实是因为$w^{2k}n&#x3D;w^k{\\frac{n}{2}}$ ，类似于快速幂的思想，按下标奇偶分着算到最后凑出来的数将会是对的\n附加的e~，感觉上来说，FT和DFT唯一的关系就在于FT对于正弦波向其出现程度的转化和出现程度逆转化回正弦波就如同DFT中对多项式的系数与点值表示法的相互转换，而FFT则是利用了一些特殊性质进行二分优化 蝶形变换我觉得还是精讲一下蝶形变换吧，毕竟这个玩意还是有一点点难想。\n蝶形变换，就是为了解决二进制反转后序号的问题，即把每一个数转换成二进制形态，再完全反转过来，按得到的数值重排。\n其实不要把蝶形变换看的很难就导致想到一些稀奇古怪的做法，事实上，他利用的更多是一种递推。\n我们得到一个下标 $a$ 所在位置 $x$ ，那么如果我想用它来得到 $a&lt;&lt;1$ 和 $(a&lt;&lt;1)+1$ 的位置该怎么做？\n类似 $dp$ 的递推，思考一下假设是正常的未变换形态，那么我们可以得到就是$x&lt;&lt;1$ 和 $(x&lt;&lt;1)+1$，毕竟就相当于左移一位了嘛，只不过奇数需要在最后一位补上一个 $1$ 。\n那相对应的，变换后的理应满足是右移一位，也就是之前的反向，而奇数就是在最高位添加一个 $1$ 。\n这样一来，我们就有$\\Theta(n)$求出蝶形变换的方法了。\n这名字听着倒还挺美","title":"快速多项式乘法","updated":"2025-09-05T13:37:49.442Z"},{"categories":[],"path":"/d-2-27/","tags":[],"text":"","title":"2-27","updated":"2025-09-05T13:27:46.052Z"},{"categories":[],"path":"/d-2-26/","tags":[],"text":"这是我在博客上加的第一篇日志欸$qwq$","title":"2-26","updated":"2025-09-05T13:27:46.052Z"}],"categories":[],"tags":[{"name":"图论","slug":"图论","permalink":"http://example.com/tags/%E5%9B%BE%E8%AE%BA/"}]}