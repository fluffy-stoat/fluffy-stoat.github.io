<!DOCTYPE html>
<html lang="zh-CN">
   

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
  <meta name="keywords" content="">
  <meta name="description" content="Ov-">
  <meta name="generator" content="Hexo 7.3.0">
  <title>斜率优化 - fluffy-stoat&#39;s Notes</title>
  <link rel="shortcut icon" href="/images/favicon.ico" />
  
<link rel="stylesheet" href="/css/ssimple.css?20251011.css">

  
<link rel="stylesheet" href="/iconfont/iconfont.css?20251011.css">

  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.css">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.13.0/dist/katex.min.js" 
    crossorigin="anonymous"></script>
  <script type="text/javascript">
    document.addEventListener("DOMContentLoaded", function(){
      window.renderKatex();
    });
  </script>


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">
<!-- hexo injector head_end end --></head>

  <body>
    <header>
  <div class="header" style="width: 100%;">
    <div class="header-inner" style="position: fixed; z-index: 20; top: 0; left: 0;">
      <div class="header-content" style="max-width: 1200px; margin: auto;">
        <div class="blog-title">
          <span class="iconfont icon-menu1" id="menu-button"></span>
          <a href="/" class="logo header-title">
            fluffy-stoat&#39;s Notes
          </a>
          
            <div class="mobile-search">
              <input type="text" />
              <span class="iconfont icon-search mobile-search-icon"></span>
              <span class="iconfont icon-baseline-close-px search-close-icon"></span>
            </div>
          
        </div>
        <div class="navbar" id="menu-list">
          <ul class="menu">
            
              <li class="menu-item">
                <a href="/archives/" class="menu-item-link">
                    
                    <span class="menu-item-icon iconfont icon-work"></span>
                    
                    Archives
                  
                </a>
              </li>
            
              <li class="menu-item">
                <a href="/directory/" class="menu-item-link">
                    
                    <span class="menu-item-icon iconfont icon-folder-close"></span>
                    
                    Directory
                  
                </a>
              </li>
            
              <li class="menu-item">
                <a href="/about/" class="menu-item-link">
                    
                    <span class="menu-item-icon iconfont icon-user"></span>
                    
                    About
                  
                </a>
              </li>
            
          </ul>
        </div>
        
          <div class="search">
            <input type="text" />
            <span class="iconfont icon-search search-icon"></span>
            <span class="iconfont icon-baseline-close-px search-close-icon"></span>
          </div>
        
      </div>
    </div>
    
      <div class="search-shadow"> </div>
      <div class="search-box">
        <div class="search-container">
  <div class="search-container-inner">
    <div class="search-data-status">
      <span>Fetching search data...</span>
    </div>
    <div class="search-count"></div>
    <div class="search-result"></div>
  </div>
</div>
      </div>
    
  </div>
</header>

    <main class="main">
      <article class="post">
  <div class="post-title">
    <h1 class="page-title">斜率优化</h1>
  </div>
  <div class="post-meta">
  <div class="post-info">
    <span class="post-info-item post-time" title="2023年7月21日星期五晚上7点48分 (CST+08:00)">
      <span class="info-icon iconfont icon-time"></span>更新于 2023年7月21日
    </span>
    
      <span class="icon infosep"></span><span class="post-info-item post-wordcount">
        <span class="info-icon iconfont icon-text"></span>约 3,035 字
      </span>
    
    
  </div>
  <div class="post-directory">
    
    <span class="iconfont icon-folder-close"></span>
    <a class="directory" href="/directory">Home</a>
    
        
        <a class="directory" href="/directory/">
          
        </a>
        <span class="icon smallarrow"></span>
    
        
        <a class="directory" href="/directory/DP/">
          DP
        </a>
        <span class="icon smallarrow"></span>
    
    当前文章
  </div>
  
  <hr />
</div>
   

  
    <div class="toc">
  
    <h2 class="toc-title">
      <span
       class="iconfont icon-explain" 
       style="font-size: 1em;padding-right: 5px;"></span
      >文章目录</h2>
    <div class="toc-content">
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#何时使用斜率优化？"><span class="toc-number">1.</span> <span class="toc-text">何时使用斜率优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#凸包的维护"><span class="toc-number">2.</span> <span class="toc-text">凸包的维护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何判断需要维护上凸包还是下凸包？"><span class="toc-number">3.</span> <span class="toc-text">如何判断需要维护上凸包还是下凸包？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何回复询问？"><span class="toc-number">4.</span> <span class="toc-text">如何回复询问？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#几个例题"><span class="toc-number">5.</span> <span class="toc-text">几个例题</span></a></li></ol>
    </div>
    <hr />
  </div>


  <div class="post-content">
    <h2 id="何时使用斜率优化？"><a href="#何时使用斜率优化？" class="headerlink" title="何时使用斜率优化？"></a>何时使用斜率优化？</h2><p>当$dp$的状态转移方程可以转换成形如$f_i=max/min(y_j+k*x_j)_{(j&lt;i)}$的形式时，可以构造凸包来维护对于每一个$i$最优的决策点$j$</p>
<h2 id="凸包的维护"><a href="#凸包的维护" class="headerlink" title="凸包的维护"></a>凸包的维护</h2><p>维护一个双端队列，</p>
<p>比如需维护上凸包时，新加进的点如果和队尾点形成直线的斜率大于等于队尾两个点的斜率，就需要弹出队尾，重复这一过程直到小于或者队内只有一点，最后再加入新点。</p>
<p>下凸包也一样。</p>
<p>值得注意的是，由于除法有精度损失，所以比较时可以采用移项转乘法来精确比较。</p>
<h2 id="如何判断需要维护上凸包还是下凸包？"><a href="#如何判断需要维护上凸包还是下凸包？" class="headerlink" title="如何判断需要维护上凸包还是下凸包？"></a>如何判断需要维护上凸包还是下凸包？</h2><p>推式子，</p>
<p>比如如果状态转移方程是$f_i=max(y_j+k*x_j)_{(j&lt;i)}$，<br>那对于$x_a&lt;x_b&lt;x_c$三个决策点，因为$b$有作为某些询问最优转移点的时刻，所以对于这些时刻的$k$有:</p>
<script type="math/tex; mode=display">
y_a+k*x_a<y_b+k*x_b</script><script type="math/tex; mode=display">
y_c+k*x_c<y_b+k*x_b</script><p>移项得：</p>
<script type="math/tex; mode=display">
-k<\cfrac{y_b-y_a}{x_b-x_a}</script><script type="math/tex; mode=display">
-k>\cfrac{y_c-y_b}{x_c-x_b}</script><p>这也就说明我们需要维护的是一个上凸包，因为只有在$-k$比$ab$线的斜率小、比$bc$线的斜率大时，取$b$为转移点才是最优的；若$bc$线的斜率大于等于$ab$线的斜率，则使$b$点为最优决策点的$k$的取值范围为空集，那么$b$也就不是一个决策点。</p>
<p>$min$的时候也是同理。</p>
<h2 id="如何回复询问？"><a href="#如何回复询问？" class="headerlink" title="如何回复询问？"></a>如何回复询问？</h2><p>询问应当是单调的，而且与凸包的单调性相匹配，比如上凸包对应的$-k$的单调性应为单调下降，下凸包则相反，查询即从队头开始，比如上凸包，若队头的线对应斜率大于$-k$，则应弹出队头，直到小于或队中只有一点，此时用队头的点作为最优决策点计答案即可。反之亦然。</p>
<p>ps:斜率不单调怎么办？其实可以，维护组成凸包的点时用数组模拟双端队列，既然里面的斜率是单调的，那就可以二分找到第一个计答案比后一个点优的点，它必然是最优转移点</p>
<h2 id="几个例题"><a href="#几个例题" class="headerlink" title="几个例题"></a>几个例题</h2><p>平面中有$n$个点$(x_i,y_i)$，有$m$条直线，斜率$k$已经确定，需要在给定的$n$个点中，选出一个点$(x_i,y_i)$，使得$kx+y$最大。</p>
<p>单纯维护斜率和查询，直接上代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll n,m,ans[100050];</span><br><span class="line">struct node&#123;</span><br><span class="line">	ll x,y;</span><br><span class="line">	bool operator &lt;(const node &amp;a)const&#123;</span><br><span class="line">		return x&lt;a.x||(x==a.x&amp;&amp;y&gt;a.y);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;p[100050],pre1,pre2;</span><br><span class="line">struct query&#123;</span><br><span class="line">	ll pos,k;</span><br><span class="line">	bool operator &lt;(const query &amp;a)const&#123;</span><br><span class="line">		return k&gt;a.k;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;q[100050];</span><br><span class="line">deque&lt;node&gt; st;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%lld%lld&quot;,&amp;n,&amp;m);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		scanf(&quot;%lld%lld&quot;,&amp;p[i].x,&amp;p[i].y);</span><br><span class="line">	&#125;</span><br><span class="line">	sort(p+1,p+1+n);</span><br><span class="line">	for(int i=1;i&lt;=m;i++)&#123;</span><br><span class="line">		scanf(&quot;%lld&quot;,&amp;q[i].k);</span><br><span class="line">		q[i].pos=i;</span><br><span class="line">	&#125;</span><br><span class="line">	sort(q+1,q+1+m);</span><br><span class="line">	for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">		if(st.size()&lt;2)&#123;</span><br><span class="line">			if(st.size()&gt;0)&#123;</span><br><span class="line">				if(p[i].x==st.front().x)&#123;</span><br><span class="line">					if(p[i].y&gt;st.front().y)st.pop_front();</span><br><span class="line">					else if(p[i].y&lt;=st.front().y)continue;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			st.push_back(p[i]);</span><br><span class="line">			continue;</span><br><span class="line">		&#125;</span><br><span class="line">		ll pd=1;</span><br><span class="line">		while(st.size()&gt;=2)&#123;</span><br><span class="line">			pre1=st.back();</span><br><span class="line">			st.pop_back();</span><br><span class="line">			pre2=st.back();</span><br><span class="line">			st.pop_back();</span><br><span class="line">			if((double)(p[i].y-pre1.y)*(pre1.x-pre2.x)&lt;(double)(pre1.y-pre2.y)*(p[i].x-pre1.x))&#123;</span><br><span class="line">				st.push_back(pre2);</span><br><span class="line">				st.push_back(pre1);</span><br><span class="line">				st.push_back(p[i]);</span><br><span class="line">				break;</span><br><span class="line">			&#125;</span><br><span class="line">			else&#123;</span><br><span class="line">				st.push_back(pre2);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		st.push_back(p[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	ll cnt=m;</span><br><span class="line">	while(cnt&gt;0&amp;&amp;st.size()&gt;1)&#123;</span><br><span class="line">		pre1=st.front();</span><br><span class="line">		st.pop_front();</span><br><span class="line">		pre2=st.front();</span><br><span class="line">		if(-q[cnt].k*(pre2.x-pre1.x)&gt;(pre2.y-pre1.y))</span><br><span class="line">		ans[q[cnt].pos]=pre1.x*q[cnt].k+pre1.y,st.push_front(pre1),cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">	while(cnt&gt;0)&#123;</span><br><span class="line">		pre1=st.front();</span><br><span class="line">		ans[q[cnt].pos]=pre1.x*q[cnt].k+pre1.y;</span><br><span class="line">		cnt--;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=1;i&lt;=m;i++)printf(&quot;%lld\n&quot;,ans[i]);</span><br><span class="line">	return 0;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>Kano准备扩大他的农场，眼下必须购买$N\le5e4$块长方形土地。如果Kano买一块土地，价格就是土地的面积。他也可以选择并购多块土地，并购的价格为这些土地中最大的长乘以最大的宽，比如Kano购买$3<em>5$和$5</em>3$的土地，只需要支付$5*5=25$元，比分开买合算。请你帮他计算购买所有土地的最小费用。</p>
<p>首先一个显然的性质是如果对于一块地有另一块地长宽均大于等于它，那它可以直接与那一块合并而不付出任何代价；<br>其次，我们对清除完合并无需付出代价的地块后，按长单增排序，宽也就会按从大到小排好，甚至是单调减而非单调不上升，根据前一个性质即可得到；<br>排序后我们可以得到一个$dp$状态转移方程：$f_i=min(f_j+w_{j+1}*l_i)_{j&lt;i}$其中$w$为宽，$l$为长，往上面套套路即可。<br>值得注意的是，这个凸包是以$x$从大到小造的，所以维护的时候还需思考它的判断式子该怎么写。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll n,cnt,l=0,r=0,f[100000];</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">    bool operator &lt;(const node &amp;a)const&#123;</span><br><span class="line">        return x&lt;a.x||(x==a.x&amp;&amp;y&lt;a.y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;c[100000],b[100000];</span><br><span class="line">struct point&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">&#125;p[100000],tmp;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld%lld&quot;,&amp;c[i].x,&amp;c[i].y);</span><br><span class="line">    &#125;</span><br><span class="line">    sort(c+1,c+1+n);</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        while(cnt&gt;0&amp;&amp;b[cnt].x&lt;=c[i].x&amp;&amp;b[cnt].y&lt;=c[i].y)cnt--;</span><br><span class="line">        b[++cnt]=c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.x=b[1].y;</span><br><span class="line">    tmp.y=0;</span><br><span class="line">    p[++r]=tmp;</span><br><span class="line">    for(int i=1;i&lt;=cnt;i++)&#123;</span><br><span class="line">        while(r-l&gt;1&amp;&amp;-b[i].x&lt;=(p[l+2].y-p[l+1].y)/(p[l+2].x-p[l+1].x))&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=p[l+1].x*b[i].x+p[l+1].y;</span><br><span class="line">        tmp.x=b[i+1].y;</span><br><span class="line">        tmp.y=f[i];</span><br><span class="line">        while(r-l&gt;1&amp;&amp;(tmp.y-p[r].y)*(p[r].x-p[r-1].x)&gt;=(p[r].y-p[r-1].y)*(tmp.x-p[r].x))&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        p[++r]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,f[cnt]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3195">玩具装箱</a><br>这题不难得到状态转移方程$f_i=min(f_j+(i-j-1-L+\sum^{i}_{k=j+1}c_k)^2)_{(j&lt;i)}$,<br>但这个式子比较抽象不好看，可以转换一下，把区间和变成前缀和相减的形式，再把前面加与减的$i$和$j$正好按同符号放进去，可得$f_i=min(f_j+(sum_i-sum_j-L-1)^2)_{(j&lt;i)}$，<br>再把与$j$有关和无关的拆分整理可得$f_i-(sum_i-L-1)^2=min(f_j+sum_j^2-2<em>(sum_i-L-1)</em>sum_j)_{(j&lt;i)}$,<br>这时候再套板子就行了，和前一个题一样，这个也是倒着造凸包。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define ll long long </span><br><span class="line">ll n,L,f[100050],sum[100050],l=0,r=0;</span><br><span class="line">struct node&#123;</span><br><span class="line">    ll x,y;</span><br><span class="line">&#125;p[100050],tmp;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%lld%lld&quot;,&amp;n,&amp;L);</span><br><span class="line">    L++;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%lld&quot;,&amp;sum[i]);</span><br><span class="line">        sum[i]+=sum[i-1]+1;</span><br><span class="line">    &#125;</span><br><span class="line">    tmp.x=0;</span><br><span class="line">    tmp.y=0;</span><br><span class="line">    p[++r]=tmp;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        ll k=sum[i]-L;</span><br><span class="line">        while(r-l&gt;1&amp;&amp;-k&lt;=(p[l+2].y-p[l+1].y)/(p[l+2].x-p[l+1].x))&#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        f[i]=k*k+p[l+1].y+p[l+1].x*k;</span><br><span class="line">        tmp.x=-2*sum[i];</span><br><span class="line">        tmp.y=f[i]+sum[i]*sum[i];</span><br><span class="line">        while(r-l&gt;1&amp;&amp;(tmp.y-p[r].y)*(p[r].x-p[r-1].x)&gt;=(p[r].y-p[r-1].y)*(tmp.x-p[r].x))&#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        p[++r]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,f[n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一次修订：增加了关于查询非单调的处理方法。</p>

  </div>
  
  <hr>
  <h3><span class="iconfont icon-history" style="padding-right: 5px;font-size: 1em;"></span>修订记录</h3>
  <div class="post-history-list"><ol reversed>
    
      <li class="post-history-item">
        2023年7月21日 第2次修订 
      </li>
    
      <li class="post-history-item">
        2023年7月19日 创建文章 
      </li>
     
  </ol></div>

  <div class="post-footer">
  <hr>
  
    <div class="next-post">
      <span class="iconfont icon-arrow-left-circle"></span> 
      <a href="/2023/07/17/杂题选讲/小技巧（1）/">
        小技巧（1）
      </a>
    </div>
  
  
    <div class="prev-post">
      <a href="/2023/07/31/杂题选讲/小技巧（3）/">
        小技巧（3）
      </a> 
      <span class="iconfont icon-arrow-right-circle"></span>
    </div>
  
</div>
</article>


  <div id="vcomments"></div>


    </main>
  </body>
  <div class="side-button">
  
    <div id="comment-button" class="button" title="Valine Comment" >
      <span class="iconfont icon-comment"></span>
    </div>
  
    <div id="darkmode-button" class="button" title="Switch between day and night" >
      <span class="iconfont icon-moonbyueliang"></span>
    </div>
  
    <div id="top" class="button" title="Back to top" >
      <span class="iconfont icon-arrowup"></span>
    </div>
  
</div>

  <footer id="footer" style="margin: 3em 0 2em 0; text-align: center; line-height: 1.4em">

  
  <div class="visitor">
    <span id="/2025/10/11/test/" class="leancloud_visitors" data-flag-title="test">
      <span class="iconfont icon-eye"></span>
      <span class="post-meta-item-text">Page view </span>
      <i class="leancloud-visitors-count"></i>
    </span>
  </div>



  
    <span class="post-wordcount iconfont icon-text"></span>
    全站约 36,077 字
  

  <div class="license" style="padding: 0 10px;">
    <span>
    本站所有文章遵循许可协议 
    <a target="_blank" rel="license noreferrer noopener" href="https://creativecommons.org/licenses/by-sa/4.0/">
      Creative Commons Attribution-ShareAlike 4.0 International License
    </a>
    </span>
  </div>

  <div class="credit">
    <span>Themed
    <a href="https://github.com/sshwy/hexo-theme-essence" target="_blank" rel="noreferrer noopener">Essence v1.10.0</a>
    | Powered by <a href="http://hexo.io" target="_blank" rel="noreferrer noopener">Hexo</a></span>
  </div>

  

  <div class="copyright">
    <span>Copyright &copy; 2023-2023 - fluffy-stoat</span>
  </div>

</footer>

  
  <script type="text/javascript">
    var valine_path = '/2023/07/21/DP/斜率优化/'
  </script>

  
<script src="/js/ssimple.js?20251011.js"></script>
<script src="https://pv.sohu.com/cityjson?ie=utf-8.js" defer></script>



  <script type="text/javascript">
    loadComments();
    function loadComments() {
      if (typeof Valine === 'undefined') {
        var getScript = (options) => {
          var script = document.createElement('script');
          script.defer = true;
          script.crossOrigin = 'anonymous';
          Object.keys(options).forEach((key) => {
            script[key] = options[key];
          });
          document.body.appendChild(script);
        };
        getScript({
          src: 'https://cdn.jsdelivr.net/npm/valine',
          onload: function () {
            newValine();
          }
        });
      } else {
        newValine();
      }
    }
    function newValine() {
      if (valine_path[valine_path.length - 1] != '\/') valine_path = valine_path + '\/';
      new Valine({
        el: '#vcomments',
        appId: '',
        appKey: '',
        placeholder: '',
        serverURLs: '',
        visitor: true,
        recordIP: true,
        requiredFields: ['nick', 'mail'],
        avatar: 'retro',
        path: valine_path
      });
    }
  </script>

</html>
